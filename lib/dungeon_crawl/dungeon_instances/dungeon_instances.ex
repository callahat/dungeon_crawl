defmodule DungeonCrawl.DungeonInstances do
  @moduledoc """
  The DungeonInstances context.
  """

  import Ecto.Query, warn: false
  alias Ecto.Multi
  alias DungeonCrawl.Repo
  alias DungeonCrawl.Dungeons

  alias DungeonCrawl.DungeonInstances.Dungeon
  alias DungeonCrawl.DungeonInstances.Level
  alias DungeonCrawl.DungeonInstances.LevelHeader
  alias DungeonCrawl.DungeonInstances.Tile


  @doc """
  Gets a single dungeon instance. Takes a dungeon, and then copies it into an instance,
  levels and all.

  Raises `Ecto.NoResultsError` if the MapSetInstance does not exist.

  ## Examples

      iex> get_dungeon!(123)
      %Level{}

      iex> get_dungeon!(456)
      ** (Ecto.NoResultsError)

  """
  def get_dungeon(id),  do: Repo.get(Dungeon, id)
  def get_dungeon!(id), do: Repo.get!(Dungeon, id)

  @doc """
  Creates a dungeon instance, initializing also the levels belonging to that dungeon.

  ## Examples

      iex> create_dungeon(%Dungeons.Dungeon{})
      {:ok, %{dungeon: %DungeonInstances.Dungeon{}, levels: [%DungeonInstances.Level{}, ...]}}
      {:ok, %Dungeon{}}

  """
  def create_dungeon(%Dungeons.Dungeon{} = dungeon, is_private \\ false, headers_only \\ false) do
    dungeon_attrs = Map.merge(%{dungeon_id: dungeon.id, is_private: is_private}, Map.take(dungeon, [:name, :autogenerated, :state]))
    Multi.new()
    |> Multi.insert(:dungeon, Dungeon.changeset(%Dungeon{}, dungeon_attrs))
    |> Multi.run(:levels, fn(_repo, %{dungeon: dungeon_instance}) ->
        result = Repo.preload(dungeon, :levels).levels
                 |> Enum.map(fn(level) ->
                      _create_dungeon_level(level, dungeon_instance.id, headers_only)
                    end)
        {:ok, result}
      end)
    |> Repo.transaction()
  end

  def _create_dungeon_level(level, di_id, true) do
    {:ok, level_header} = create_level_header(level, di_id)
    level_header
  end

  def _create_dungeon_level(level, di_id, _headers_only) do
    {:ok, level_header} = create_level_header(level, di_id)
    {:ok, %{level: level}} = create_level(level, level_header.id, di_id)
    level
  end

  @doc """
  Deletes a Dungeon Instance.

  ## Examples

      iex> delete_dungeon(dungeon)
      {:ok, %Dungeon{}}

  """
  def delete_dungeon(%Dungeon{} = dungeon) do
    Repo.preload(dungeon, :levels).levels
    |> Enum.each(fn(level) -> Repo.delete!(level) end)
    Repo.delete!(dungeon)
  end

  @doc """
  Gets a single level instance.

  Raises `Ecto.NoResultsError` if the Level Instance does not exist.

  ## Examples

      iex> get_level!(123)
      %Level{}

      iex> get_level!(456)
      ** (Ecto.NoResultsError)

  """
  def get_level(id),  do: Repo.get(Level, id)
  def get_level!(id), do: Repo.get!(Level, id)

  def get_level(_dungeon_instance_id, _level, location_id \\ nil)
  def get_level(_dungeon_instance_id, nil, _), do: nil
  def get_level(dungeon_instance_id, level, nil) do
    Repo.one(from l in Level,
             where: l.dungeon_instance_id == ^dungeon_instance_id and
                    l.number == ^level and
                    is_nil(l.player_location_id),
             limit: 1)
  end
  def get_level(dungeon_instance_id, level, location_id) do
    Repo.get_by(Level, %{dungeon_instance_id: dungeon_instance_id, number: level, player_location_id: location_id})
  end

  @doc """
  Gets the adjacent level instances, returns a level of the direction as the key and the instance as the value.

  ## Examples

    iex> get_adjacent_levels(123)
    %{"north" => %Level{},...}

    iex> get_adjacent_levels(456)
    %{"north" => nil, ...}
  """
  def get_adjacent_levels(%Level{} = instance) do
    %{"north" => if(instance.number_north, do: get_level(instance.dungeon_instance_id, instance.number_north)) || %{number: nil},
      "south" => if(instance.number_south, do: get_level(instance.dungeon_instance_id, instance.number_south)) || %{number: nil},
      "east" => if(instance.number_east, do: get_level(instance.dungeon_instance_id, instance.number_east)) || %{number: nil},
      "west" => if(instance.number_west, do: get_level(instance.dungeon_instance_id, instance.number_west)) || %{number: nil}}
  end
  def get_adjacent_levels(id), do: get_adjacent_levels(get_level(id))

  @doc """
  Creates a level header.

  ## Examples

      iex> create_level_header(%Dungeons.Level{})
      {:ok, %DungeonInstances.LevelHeader{}}

  """
  def create_level_header(%Dungeons.Level{} = level, di_id) do
    # TODO: figure out what the type is
    level_header_attrs = %{level_id: level.id, number: level.number, dungeon_instance_id: di_id}
    LevelHeader.changeset(%LevelHeader{}, level_header_attrs)
    |> Repo.insert
  end

  @doc """
  Finds or creates the level instance given a header and player location id.

  ## Examples

      iex> find_or_create_level(%Dungeons.LevelHeader{}, 123)
      %DungeonInstances.Level{}

  """
  def find_or_create_level(%LevelHeader{type: :universal,
                                        id: lh_id,
                                        dungeon_instance_id: di_id,
                                        number: number} = level_header,
                           _player_location_id) do

    case get_level(di_id, number) do
      nil ->
        {:ok, %{level: level}} = create_level(Repo.preload(level_header, :level).level, lh_id, di_id)
        level

      level ->
        level
    end
  end
  def find_or_create_level(%LevelHeader{type: :solo,
                                        id: lh_id,
                                        dungeon_instance_id: di_id,
                                        number: number} = level_header,
                           player_location_id) do

    case get_level(di_id, number, player_location_id) do
      nil ->
        {:ok, %{level: level}} = create_level(Repo.preload(level_header, :level).level, lh_id, di_id, player_location_id)
        level

      level ->
        level
    end
  end

  @doc """
  Creates a level instance.

  ## Examples

      iex> create_level(%Dungeons.Level{}, level_header_id, dungeon_instance_id)
      {:ok, %{level: %DungeonInstances.Level{}}}

  """
  def create_level(%Dungeons.Level{} = level, lh_id, di_id, loc_id \\ nil) do
    level_attrs = Map.merge(Dungeons.copy_level_fields(level),
      %{dungeon_instance_id: di_id, level_header_id: lh_id, level_id: level.id, player_location_id: loc_id})
    Multi.new()
    |> Multi.insert(:level, Level.changeset(%Level{}, level_attrs))
    |> Multi.run(:tiles, fn(_repo, %{level: level_instance}) ->
        result = _tile_instances(level_instance.id, level)
                 |> Enum.chunk_every(1_000,1_000,[])
                 |> Enum.reduce(0, fn(tiles, acc) ->
                     {count, _} = Repo.insert_all(Tile, tiles)
                     count + acc
                    end )
        {:ok, result}
      end)
    |> Repo.transaction()
  end

  defp _tile_instances(level_instance_id, %Dungeons.Level{} = level) do
    Repo.preload(level, :tiles).tiles
    |> Enum.map(fn(t) ->
         Map.merge(Dungeons.copy_tile_fields(t), %{level_instance_id: level_instance_id})
         |> Map.delete(:tile_template_id)
       end)
  end

  @doc """
  Deletes a Level Instance.

  ## Examples

      iex> delete_level(level)
      {:ok, %Level{}}

      iex> delete_level(level)
      {:error, %Ecto.Changeset{}}

  """
  def delete_level(%Level{} = level) do
    Repo.delete(level)
  end
  def delete_level!(%Level{} = level) do
    Repo.delete!(level)
  end

  alias DungeonCrawl.DungeonInstances.Tile

  @doc """
  Gets a single tile_instance, with the highest z_index for given coordinates

  Returns `nil` if the Map tile does not exist.

  ## Examples

      iex> get_tile(123)
      %Tile{}

      iex> get_tile(456)
      nil

  """
  def get_tile(level_instance_id, row, col) do
    Repo.one(from t in Tile,
             where: t.level_instance_id == ^level_instance_id and t.row == ^row and t.col == ^col,
             order_by: [desc: :z_index],
             limit: 1)
  end

  @doc """
  Returns a single tile_instance based on the given id.
  """
  def get_tile_by_id(tile_id) do
    Repo.get(Tile, tile_id)
  end

  @doc """
  Returns a tuple containing a status atom and either the new tile that has not been persisted to the database
  (when the attrs are valid), OR returns the invalid changeset.
  This function will be used for Instance processes when a tile is created but will either be saved to the database
  later, or will not be long lived enough to bother persisting further down than the instance process.

  ## Examples

      iex> create_tile(%{field: value})
      {:ok, %Tile{}}

      iex> create_tile(%{field: bad_value})
      {:error, %Ecto.Changeset{}}

  """
  def new_tile(attrs \\ %{}) do
    changeset = Tile.changeset(%Tile{}, attrs)
    if changeset.valid? do
      {:ok, Map.merge(%Tile{}, changeset.changes)}
    else
      {:error, changeset}
    end
  end

  @doc """
  Creates a tile.

  ## Examples

      iex> create_tile(%{field: value})
      {:ok, %Tile{}}

      iex> create_tile(%{field: bad_value})
      {:error, %Ecto.Changeset{}}

  """
  def create_tile(attrs \\ %{}) do
    %Tile{}
    |> Tile.changeset(attrs)
    |> Repo.insert()
  end
  def create_tile!(attrs \\ %{}) do
    %Tile{}
    |> Tile.changeset(attrs)
    |> Repo.insert!()
  end

  @doc """
  Updates the given tiles.

  ## Examples

      iex> update_tiles([<tile changeset>, <tile changeset>, ...])
      {3, nil}

  """
  def update_tiles(tile_changesets) do
    Multi.new
    |> Multi.run(:tile_updates, fn(_repo, %{}) ->
        result = tile_changesets
                 |> Enum.chunk_every(1_000,1_000,[])
                 |> Enum.reduce(0, fn(chunked_changesets, acc) ->
                     Enum.reduce(chunked_changesets, 0, fn(tile_changeset, acc) ->
                       Repo.update(tile_changeset)
                       1 + acc
                      end ) + acc
                    end )
        {:ok, result}
      end)
    |> Repo.transaction()
  end

  @doc """
  Deletes the given tiles.

  ## Examples

      iex> delete_tiles([tile_id_1, tile_id_2, ...])
      {3, nil}

  """
  def delete_tiles(tile_ids) do
    from(t in Tile, where: t.id in ^tile_ids)
    |> Repo.delete_all()
  end
end
