defmodule DungeonCrawl.DungeonInstances do
  @moduledoc """
  The DungeonInstances context.
  """

  import Ecto.Query, warn: false
  alias Ecto.Multi
  alias DungeonCrawl.Repo
  alias DungeonCrawl.Dungeons

  alias DungeonCrawl.DungeonInstances.Dungeon
  alias DungeonCrawl.DungeonInstances.Level
  alias DungeonCrawl.DungeonInstances.LevelHeader
  alias DungeonCrawl.DungeonInstances.Tile


  @doc """
  Gets a single dungeon instance. Takes a dungeon, and then copies it into an instance,
  levels and all.

  Raises `Ecto.NoResultsError` if the MapSetInstance does not exist.

  ## Examples

      iex> get_dungeon!(123)
      %Level{}

      iex> get_dungeon!(456)
      ** (Ecto.NoResultsError)

  """
  def get_dungeon(id),  do: Repo.get(Dungeon, id)
  def get_dungeon!(id), do: Repo.get!(Dungeon, id)

  @doc """
  Creates a dungeon instance, initializing also the levels belonging to that dungeon.

  ## Examples

      iex> create_dungeon(%Dungeons.Dungeon{}, "jimbob")
      {:ok, %{dungeon: %DungeonInstances.Dungeon{}, levels: [%DungeonInstances.Level{}, ...]}}
      {:ok, %Dungeon{}}

  """
  def create_dungeon(%Dungeons.Dungeon{} = dungeon, host_name, is_private \\ false, headers_only \\ false) do
    dungeon_attrs = Map.merge(%{host_name: host_name, dungeon_id: dungeon.id, is_private: is_private}, Map.take(dungeon, [:name, :autogenerated, :state]))
    Multi.new()
    |> Multi.insert(:dungeon, Dungeon.changeset(%Dungeon{}, dungeon_attrs))
    |> Multi.run(:levels, fn(_repo, %{dungeon: dungeon_instance}) ->
        result = Repo.preload(dungeon, :levels).levels
                 |> Enum.map(fn(level) ->
                      _create_dungeon_level(level, dungeon_instance.id, headers_only)
                    end)
        {:ok, result}
      end)
    |> Repo.transaction()
  end

  def _create_dungeon_level(level, di_id, true) do
    {:ok, level_header} = create_level_header(level, di_id)
    level_header
  end

  def _create_dungeon_level(level, di_id, _headers_only) do
    {:ok, level_header} = create_level_header(level, di_id)
    {:ok, %{level: level}} = create_level(level, level_header.id, di_id)
    level
  end

  @doc """
  Updates a dungeon instance

  ## Examples

      iex> update_dungeon(123, attrs)
      {:ok, dungeon}

      iex> update_dungeon(dungeon, attrs)
      {:ok, dungeon}
  """
  def update_dungeon(nil, _dungeon_attrs) do
    nil
  end

  def update_dungeon(%Dungeon{} = dungeon, dungeon_attrs) do
    Dungeon.changeset(dungeon, dungeon_attrs)
    |> Repo.update()
  end

  def update_dungeon(dungeon_id, dungeon_attrs) do
    get_dungeon(dungeon_id)
    |> update_dungeon(dungeon_attrs)
  end

  @doc """
  Deletes a Dungeon Instance.

  ## Examples

      iex> delete_dungeon(dungeon)
      {:ok, %Dungeon{}}

  """
  def delete_dungeon(%Dungeon{} = dungeon) do
    Repo.preload(dungeon, :levels).levels
    |> Enum.each(fn(level) -> Repo.delete!(level) end)
    Repo.delete!(dungeon)
  end

  @doc """
  Gets a single level instance.

  Raises `Ecto.NoResultsError` if the Level Instance does not exist.

  ## Examples

      iex> get_level!(123)
      %Level{}

      iex> get_level!(456)
      ** (Ecto.NoResultsError)

  """
  def get_level(id),  do: Repo.get(Level, id)
  def get_level!(id), do: Repo.get!(Level, id)

  def get_level(_dungeon_instance_id, _level, location_id \\ nil)
  def get_level(_dungeon_instance_id, nil, _), do: nil
  def get_level(dungeon_instance_id, level, nil) do
    Repo.one(from l in Level,
             where: l.dungeon_instance_id == ^dungeon_instance_id and
                    l.number == ^level and
                    is_nil(l.player_location_id),
             limit: 1)
  end
  def get_level(dungeon_instance_id, level, location_id) do
    Repo.get_by(Level, %{dungeon_instance_id: dungeon_instance_id, number: level, player_location_id: location_id})
  end

  @doc """
  Gets the adjacent level instances, returns a level of the direction as the key and the instance as the value.

  ## Examples

    iex> get_adjacent_levels(123)
    %{"north" => %Level{},...}

    iex> get_adjacent_levels(456)
    %{"north" => nil, ...}
  """
  def get_adjacent_levels(%Level{} = instance) do
    %{"north" => instance.number_north,
      "south" => instance.number_south,
      "east" => instance.number_east,
      "west" => instance.number_west}
  end
  def get_adjacent_levels(id), do: get_adjacent_levels(get_level(id))

  @doc """
  Creates a level header.

  ## Examples

      iex> create_level_header(%Dungeons.Level{}, dungeon_instance_id)
      {:ok, %DungeonInstances.LevelHeader{}}

  """
  def create_level_header(%Dungeons.Level{} = level, di_id) do
    # TODO: figure out what the type is
    level_header_attrs = %{level_id: level.id,
                           number: level.number,
                           dungeon_instance_id: di_id,
                           type: _level_header_type(level)}
    LevelHeader.changeset(%LevelHeader{}, level_header_attrs)
    |> Repo.insert
  end

  defp _level_header_type(level) do
    if level.state && level.state =~ ~r/solo:\s+true/, do: :solo, else: :universal
  end

  @doc """
  Looks up a level header.

  ## Examples

      iex> get_level_header(dungeon_instance_id, level_number)
      %DungeonInstances.LevelHeader{}
  """
  def get_level_header(dungeon_instance_id, level) do
    Repo.get_by(LevelHeader, %{dungeon_instance_id: dungeon_instance_id, number: level})
  end

  @doc """
  Finds or creates the level instance given a header and player location id.

  ## Examples

      iex> find_or_create_level(%Dungeons.LevelHeader{}, 123)
      %DungeonInstances.Level{}

  """
  def find_or_create_level(nil, _), do: nil
  def find_or_create_level(%LevelHeader{type: :universal,
                                        id: lh_id,
                                        dungeon_instance_id: di_id,
                                        number: number} = level_header,
                           _player_location_id) do

    case get_level(di_id, number) do
      nil ->
        {:ok, %{level: level}} = create_level(Repo.preload(level_header, :level).level, lh_id, di_id)
        level

      level ->
        level
    end
  end
  def find_or_create_level(%LevelHeader{type: :solo,
                                        id: lh_id,
                                        dungeon_instance_id: di_id,
                                        number: number} = level_header,
                           player_location_id) do

    case get_level(di_id, number, player_location_id) do
      nil ->
        {:ok, %{level: level}} = create_level(Repo.preload(level_header, :level).level, lh_id, di_id, player_location_id)
        level

      level ->
        level
    end
  end

  @doc """
  Creates a level instance.

  ## Examples

      iex> create_level(%Dungeons.Level{}, level_header_id, dungeon_instance_id)
      {:ok, %{level: %DungeonInstances.Level{}}}

  """
  def create_level(%Dungeons.Level{} = level, lh_id, di_id, loc_id \\ nil) do
    level_attrs = Map.merge(Dungeons.copy_level_fields(level),
      %{dungeon_instance_id: di_id, level_header_id: lh_id, level_id: level.id, player_location_id: loc_id})
    Multi.new()
    |> Multi.insert(:level, Level.changeset(%Level{}, level_attrs))
    |> Multi.run(:tiles, fn(_repo, %{level: level_instance}) ->
        result = _tile_instances(level_instance.id, level)
                 |> Enum.chunk_every(1_000,1_000,[])
                 |> Enum.reduce(0, fn(tiles, acc) ->
                     {count, _} = Repo.insert_all(Tile, tiles)
                     count + acc
                    end )
        {:ok, result}
      end)
    |> Repo.transaction()
  end

  defp _tile_instances(level_instance_id, %Dungeons.Level{} = level) do
    Repo.preload(level, :tiles).tiles
    |> Enum.map(fn(t) ->
         Map.merge(Dungeons.copy_tile_fields(t), %{level_instance_id: level_instance_id})
         |> Map.delete(:tile_template_id)
       end)
  end

  @doc """
  Updates a level instance

  ## Examples

      iex> update_level(123, attrs)
      {:ok, level}

      iex> update_level(level, attrs)
      {:ok, level}
  """
  def update_level(nil, _level_attrs) do
    nil
  end

  def update_level(%Level{} = level, level_attrs) do
    Level.changeset(level, level_attrs)
    |> Repo.update()
  end

  def update_level(level_id, level_attrs) do
    get_level(level_id)
    |> update_level(level_attrs)
  end

  @doc """
  Deletes a Level Instance.

  ## Examples

      iex> delete_level(level)
      {:ok, %Level{}}

      iex> delete_level(level)
      {:error, %Ecto.Changeset{}}

  """
  def delete_level(%Level{} = level) do
    Repo.delete(level)
  end
  def delete_level!(%Level{} = level) do
    Repo.delete!(level)
  end

  @doc """
  Gets the tile differences for the given instance and the base level
  """
  def tile_difference_from_base(%Level{} = level) do
    base_level = Repo.preload(level, :level).level
    tile_difference(level, base_level)
  end

  @doc """
  Gets the tile differences between the two levels returning a list with two lists.
  First list being tiles in the first level not in the second one (ie, new tiles),
  second list being the tiles in the second level but not the first one (ie, deleted tiles).
  """
  def tile_difference(%Level{id: level_id}, %Dungeons.Level{id: base_level_id}) do
    _tile_difference(
      _instance_tiles(level_id),
      _base_level_tiles(base_level_id))
  end

  def tile_difference(%Level{id: level_id}, %Level{id: base_level_id}) do
    _tile_difference(
      _instance_tiles(level_id),
      _base_level_instance_tiles(base_level_id))
  end

  def _tile_difference(current_tiles_query, base_tiles_query) do
    new_tiles = Repo.all(from ti in current_tiles_query,
                         except: ^_unchanged_instance_tiles(current_tiles_query, base_tiles_query))
    deleted_tiles = Repo.all(from t in base_tiles_query,
                             except: ^_unchanged_base_tiles(current_tiles_query, base_tiles_query))
    [new_tiles, deleted_tiles]
  end

  defp _unchanged_instance_tiles(current_tiles_query, base_tiles_query) do
    from ti in current_tiles_query,
         right_join: bt in subquery(base_tiles_query),
         on: bt.row == ti.row and bt.col == ti.col and bt.z_index == ti.z_index,
         where: coalesce(ti.name, "") == coalesce(bt.name, "") and
                coalesce(ti.state, "") == coalesce(bt.state, "") and
                coalesce(ti.script, "") == coalesce(bt.script, "")
  end

  defp _unchanged_base_tiles(current_tiles_query, base_tiles_query) do
    from bt in base_tiles_query,
    left_join: ti in subquery(current_tiles_query),
    on: bt.row == ti.row and bt.col == ti.col and bt.z_index == ti.z_index,
    where: coalesce(ti.name, "") == coalesce(bt.name, "") and
           coalesce(ti.state, "") == coalesce(bt.state, "") and
           coalesce(ti.script, "") == coalesce(bt.script, "")
  end

  defp _instance_tiles(level_instance_id) do
    from ti in Tile, where: ti.level_instance_id == ^level_instance_id
  end

  defp _base_level_tiles(base_level_id) do
    from t in Dungeons.Tile, where: t.level_id == ^base_level_id
  end

  defp _base_level_instance_tiles(base_level_id) do
    from t in Tile, where: t.level_instance_id == ^base_level_id
  end

  @doc """
  Gets a single tile_instance, with the highest z_index for given coordinates

  Returns `nil` if the Map tile does not exist.

  ## Examples

      iex> get_tile(123, 1,3)
      %Tile{}

      iex> get_tile(456, 13324, 13432)
      nil

  """
  def get_tile(level_instance_id, row, col) do
    Repo.one(from t in Tile,
             where: t.level_instance_id == ^level_instance_id and t.row == ^row and t.col == ^col,
             order_by: [desc: :z_index],
             limit: 1)
  end

  def get_tile(level_instance_id, row, col, z_index) do
    Repo.one(from t in Tile,
             where: t.level_instance_id == ^level_instance_id and
                    t.row == ^row and
                    t.col == ^col and
                    t.z_index == ^z_index,
             limit: 1)
  end

  @doc """
  Returns a single tile_instance based on the given id.
  """
  def get_tile_by_id(tile_id) do
    Repo.get(Tile, tile_id)
  end

  @doc """
  Returns a tuple containing a status atom and either the new tile that has not been persisted to the database
  (when the attrs are valid), OR returns the invalid changeset.
  This function will be used for Instance processes when a tile is created but will either be saved to the database
  later, or will not be long lived enough to bother persisting further down than the instance process.

  ## Examples

      iex> new_tile(%{field: value})
      {:ok, %Tile{}}

      iex> new_tile(%{field: bad_value})
      {:error, %Ecto.Changeset{}}

  """
  def new_tile(attrs \\ %{}) do
    changeset = Tile.changeset(%Tile{}, attrs)
    if changeset.valid? do
      {:ok, Map.merge(%Tile{}, changeset.changes)}
    else
      {:error, changeset}
    end
  end

  @doc """
  Creates a tile.

  ## Examples

      iex> create_tile(%{field: value})
      {:ok, %Tile{}}

      iex> create_tile(%{field: bad_value})
      {:error, %Ecto.Changeset{}}

  """
  def create_tile(attrs \\ %{}) do
    %Tile{}
    |> Tile.changeset(attrs)
    |> Repo.insert()
  end
  def create_tile!(attrs \\ %{}) do
    %Tile{}
    |> Tile.changeset(attrs)
    |> Repo.insert!()
  end

  @doc """
  Updates the given tiles.

  ## Examples

      iex> update_tiles([<tile changeset>, <tile changeset>, ...])
      {3, nil}

  """
  def update_tiles(tile_changesets) do
    Multi.new
    |> Multi.run(:tile_updates, fn(_repo, %{}) ->
        result = tile_changesets
                 |> Enum.chunk_every(1_000,1_000,[])
                 |> Enum.reduce(0, fn(chunked_changesets, acc) ->
                     Enum.reduce(chunked_changesets, 0, fn(tile_changeset, acc) ->
                       Repo.update(tile_changeset)
                       1 + acc
                      end ) + acc
                    end )
        {:ok, result}
      end)
    |> Repo.transaction()
  end

  @doc """
  Deletes the given tiles.

  ## Examples

      iex> delete_tiles([tile_id_1, tile_id_2, ...])
      {3, nil}

  """
  def delete_tiles(tile_ids) do
    from(t in Tile, where: t.id in ^tile_ids)
    |> Repo.delete_all()
  end
end
