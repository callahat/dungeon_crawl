defmodule DungeonCrawl.DungeonProcesses.DungeonProcess do
  use GenServer, restart: :temporary

  alias DungeonCrawl.Account.User
  alias DungeonCrawl.DungeonInstances
  alias DungeonCrawl.DungeonProcesses.DungeonProcess
  alias DungeonCrawl.DungeonProcesses.LevelRegistry
  alias DungeonCrawl.Games

  require Logger

  defstruct dungeon: nil,
            dungeon_instance: nil,
            state_values: %{},
            instance_registry: %{},
            entrances: [],
            author: %User{}

  @timeout 60_000

  ## Client API

  @doc """
  Starts the instance process.
  """
  def start_link(opts) do
    GenServer.start_link(__MODULE__, :ok, opts)
  end

  @doc """
  Returns true if the dungeon instance can have a score created for its parent dungeon,
  or false if it is ineligible (ie, autogenerated, configuration says so, etc).
  """
  def scorable?(server) do
    GenServer.call(server, {:scorable?})
  end

  @doc """
  Sets the author, which can be used for validations such as if a particular slug
  may be used.
  """
  def set_author(server, author) do
    GenServer.call(server, {:set_author, author})
  end

  @doc """
  Gets the author.
  """
  def get_author(server) do
    GenServer.call(server, {:get_author})
  end

  @doc """
  Sets the dungeon
  """
  def set_dungeon(server, dungeon) do
    GenServer.call(server, {:set_dungeon, dungeon})
  end

  @doc """
  Sets the dungeon instance
  """
  def set_dungeon_instance(server, dungeon_instance) do
    GenServer.call(server, {:set_dungeon_instance, dungeon_instance})
  end

  @doc """
  Sets the state values for the map set process. This will overwrite whatever state values currently exist.
  """
  def set_state_values(server, state_values) do
    GenServer.call(server, {:set_state_values, state_values})
  end

  @doc """
  Sets a state value
  """
  def set_state_value(server, key, value) do
    GenServer.call(server, {:set_state_value, key, value})
  end

  @doc """
  Gets a state value
  """
  def get_state_value(server, key) do
    GenServer.call(server, {:get_state_value, key})
  end

  @doc """
  Looks up the instance pid for `instance_id` stored in `server`.

  Returns `{:ok, pid}` if the instance exists, `:error` otherwise
  """
  def get_instance_registry(server) do
    GenServer.call(server, {:get_instance_registry})
  end

  @doc """
  Gets the dungeon
  """
  def get_dungeon(server) do
    GenServer.call(server, {:get_dungeon})
  end

  @doc """
  Inspect the state
  """
  def get_state(server) do
    GenServer.call(server, {:get_state})
  end

  @doc """
  Loads a level instance and adds it on the instance registry.
  """
  def load_instance(server, level_instance_id) when is_integer(level_instance_id) do
    load_instance(server, DungeonInstances.get_level(level_instance_id))
  end

  def load_instance(server, level_instance) do
    GenServer.call(server, {:load_instance, level_instance})
  end

  @doc """
  Starts the scheduler which checks for players periodically. If there are none, terminates the
  process and handles the database tables appropriately (ie, deletes them)
  """
  def start_scheduler(server, timeout \\ @timeout) do
    Process.send_after(server, :check_for_players, timeout)
  end

  ## Defining GenServer Callbacks

  @impl true
  def init(:ok) do
    {:ok, instance_registry} = LevelRegistry.start_link(self(), [])
# might need this
#    LevelRegistry.link_dungeon(program_registry, self())
    {:ok, %DungeonProcess{instance_registry: instance_registry}}
  end

  @impl true
  def handle_call({:scorable?}, _from, %{dungeon: dungeon, state_values: state_values} = state) do
    {:reply, dungeon.autogenerated || (dungeon.active && ! state_values["no_scoring"]), state}
  end

  @impl true
  def handle_call({:set_author, author}, _from, state) do
    {:reply, :ok, %{ state | author: author }}
  end

  @impl true
  def handle_call({:get_author}, _from, %{ author: author} = state) do
    {:reply, author, state}
  end

  @impl true
  def handle_call({:set_dungeon, dungeon}, _from, state) do
    {:reply, :ok, %{ state | dungeon: dungeon }}
  end

  @impl true
  def handle_call({:set_dungeon_instance, dungeon_instance}, _from, state) do
    Process.set_label("DungeonProcess - #{ dungeon_instance.name }")
    LevelRegistry.set_dungeon_instance_id(state.instance_registry, dungeon_instance.id)
    {:reply, :ok, %{ state | dungeon_instance: dungeon_instance }}
  end

  @impl true
  def handle_call({:set_state_values, state_values}, _from, state) do
    {:reply, :ok, %{ state | state_values: state_values }}
  end

  @impl true
  def handle_call({:set_state_value, key, value}, _from, %{state_values: state_values} = state) do
    state_values = Map.put(state_values, key, value)
    {:reply, :ok, %{ state | state_values: state_values }}
  end

  @impl true
  def handle_call({:get_state_value, key}, _from, %{state_values: state_values} = state) do
    {:reply, state_values[key], state}
  end

  @impl true
  def handle_call({:get_instance_registry}, _from, state) do
    {:reply, state.instance_registry, state}
  end

  @impl true
  def handle_call({:get_dungeon}, _from, state) do
    {:reply, state.dungeon, state}
  end

  @impl true
  def handle_call({:get_state}, _from, state) do
    {:reply, state, state}
  end

  @impl true
  def handle_call({:load_instance, level_instance}, _from, state) do
    LevelRegistry.create(state.instance_registry, level_instance)

    if level_instance.entrance do
      {:reply, :ok, %{ state | entrances: [ level_instance.id | state.entrances ] }}
    else
      {:reply, :ok, state}
    end
  end

  @impl true
  def handle_info(:check_for_players, state) do
    if Enum.count(LevelRegistry.player_location_ids(state.instance_registry)) > 0 do
      Process.send_after(self(), :check_for_players, @timeout)

      {:noreply, state}
    else
      # for now, delete the backing db and stop the processes. Maybe later have dungeon instances be configurable
      # to stick around when empty (but idle the processes)
      Logger.info "Dungeon Process ##{state.dungeon_instance.id} terminating after a period of time with no players"

      _handle_idle_dungeon(state)

      {:stop, :normal, state}
    end
  end

  defp _handle_idle_dungeon(%{dungeon: %{autogenerated: true}} = state) do
    DungeonCrawl.Dungeons.hard_delete_dungeon!(state.dungeon)
  end

  defp _handle_idle_dungeon(state) do
    if(Games.has_saved_games?(state.dungeon_instance)) do
      DungeonInstances.update_dungeon(state.dungeon_instance, %{
        state: state.state_values
      })
    else
      DungeonInstances.delete_dungeon(state.dungeon_instance)
    end
  end
end

