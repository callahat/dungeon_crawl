defmodule DungeonCrawl.Dungeons do
  alias Ecto.Multi

  @moduledoc """
  The Dungeon context.
  """

  import Ecto.Query, warn: false
  alias DungeonCrawl.Repo

  alias DungeonCrawl.Account.User

  alias DungeonCrawl.Dungeons.Dungeon
  alias DungeonCrawl.Dungeons.Level
  alias DungeonCrawl.Dungeons.Tile
  alias DungeonCrawl.Dungeons.SpawnLocation

  alias DungeonCrawl.DungeonInstances

  alias DungeonCrawl.Scores.Score

  alias DungeonCrawl.TileTemplates.TileTemplate
  alias DungeonCrawl.TileTemplates.TileSeeder

  @copiable_dungeon_fields [:name,
                            :description,
                            :user_id,
                            :state,
                            :autogenerated,
                            :default_map_width,
                            :default_map_height,
                            :line_identifier,
                            :title_number
                            ]

  @copiable_level_fields [:name,
                          :width,
                          :height,
                          :number,
                          :entrance,
                          :state,
                          :number_north,
                          :number_south,
                          :number_east,
                          :number_west]

  @copiable_tile_fields [:row,
                         :col,
                         :z_index,
                         :tile_template_id,
                         :character,
                         :color,
                         :background_color,
                         :state,
                         :script,
                         :name,
                         :animate_random,
                         :animate_period,
                         :animate_characters,
                         :animate_colors,
                         :animate_background_colors]

  @doc """
  Returns the list of dungeons.
  If given a user, the list will only contain dungeons owned by that user

  ## Examples

      iex> list_dungeons()
      [%Dungeon{}, ...]

      iex> list_dungeons(user)
      [%Dungeon{}, ...]

  """
  def list_dungeons(%User{} = user) do
    Repo.all(from d in Dungeon,
             where: d.user_id == ^user.id,
             where: is_nil(d.deleted_at))
  end
  def list_dungeons(:soft_deleted) do
    Repo.all(from d in Dungeon,
             where: not(is_nil(d.deleted_at)),
             order_by: [:name, :version])
  end
  def list_dungeons() do
    Repo.all(from d in Dungeon,
             where: is_nil(d.deleted_at))
  end

  @doc """
  Returns a list of dungeons with the instances and players preloaded.
  With `:not_autogenerated`, only returns dungeons that were not autogenerated.

  ## Examples

    iex > list_dungeons_with_player_count()
    [%{dungeon: %Dungeon{}, player_count: 4}, ...]
  """
  def list_dungeons_with_player_count() do
    Repo.all(from d in Dungeon,
             where: is_nil(d.deleted_at),
             left_join: di in assoc(d, :dungeon_instances),
             left_join: li in assoc(di, :levels),
             left_join: t in assoc(li, :tiles),
             left_join: pmt in assoc(t, :player_location),
             preload: [:user, :locations, dungeon_instances: {di, locations: pmt}],
             select: %{dungeon_id: d.id, dungeon: d},
             order_by: [d.name, pmt.id])
  end

  @doc """
  Returns a list of dungeons with the instances and players preloaded.
  With `:not_autogenerated`, only returns dungeons that were not autogenerated.

  ## Examples

    iex > list_dungeons_with_player_count()
    [%{dungeon: %Dungeon{}, player_count: 4}, ...]
  """
  def list_active_dungeons_with_player_count() do
    # Todo: move the counts back here
    Repo.all(from d in Dungeon,
             where: is_nil(d.deleted_at),
             where: d.active == ^true,
             left_join: di in assoc(d, :dungeon_instances),
             left_join: li in assoc(di, :levels),
             left_join: t in assoc(li, :tiles),
             left_join: pmt in assoc(t, :player_location),
             preload: [:user, :locations, dungeon_instances: {di, locations: pmt}],
             select: %{dungeon_id: d.id, dungeon: d},
             order_by: [d.name, pmt.id])
  end

  @doc """
  Gets the number of instances for the given Dungeon.

    ## Examples

    iex > instance_count(%Dungeon{})
    3
  """
  def instance_count(%Dungeon{id: dungeon_id}), do: instance_count(dungeon_id)
  def instance_count(dungeon_id) do
    Repo.one(from instance in DungeonInstances.Dungeon,
               where: instance.dungeon_id == ^dungeon_id,
               group_by: instance.dungeon_id,
               select: count(instance.dungeon_id)) || 0
  end

  @doc """
  Gets a single dungeon.

  Raises `Ecto.NoResultsError` if the Dungeon does not exist.

  ## Examples

      iex> get_dungeon!(123)
      %Dungeon{}

      iex> get_dungeon!(456)
      ** (Ecto.NoResultsError)

  """
  def get_dungeon(id),  do: Repo.get(Dungeon, id)
  def get_dungeon!(id), do: Repo.get!(Dungeon, id)

  @doc """
  Gets the other dungeon versions associated with this dungeon, includes the score count.
  """
  def get_dungeons(line_identifier) do
    Repo.all(from d in Dungeon,
             left_join: s in Score, on: s.dungeon_id == d.id,
             where: d.line_identifier == ^line_identifier,
             group_by: d.id,
             order_by: [desc: d.version],
             select_merge: %{score_count: count(s.id)})
  end

  @doc """
  Returns the title level. When no title_number is set, defaults to the first level.
  """
  def get_title_level(%Dungeon{title_number: nil} = dungeon) do
    Repo.one(from l in Level,
             where: l.dungeon_id == ^dungeon.id,
             order_by: [asc: :id],
             limit: 1)
  end
  def get_title_level(%Dungeon{title_number: title_number} = dungeon) do
    Repo.one(from m in Level,
             where: m.number == ^title_number,
             where: m.dungeon_id == ^dungeon.id,
             order_by: [asc: :id],
             limit: 1)
  end

  @doc """
  Returns a boolean indicating wether or not the given dungeon has a next version, or is the most current one.

  ## Examples

      iex> next_version_exists?(%Dungeon{})
      true

      iex> next_version_exists?(%Dungeon{})
      false
  """
  def next_version_exists?(%Dungeon{} = dungeon) do
    Repo.one(from d in Dungeon, where: d.previous_version_id == ^dungeon.id, select: count(d.id)) > 0
  end

  @doc """
  Copies a dungeon and returns a map of the copied fields. Does not include the id or other record specific keys.

  ## Examples

      iex> copy_dungeon_fields(%{id: 1, name: value, ...})
      %{name: value}

      iex> copy_dungeon_fields(nil)
      %{}
  """
  def copy_dungeon_fields(nil), do: %{}
  def copy_dungeon_fields(dungeon) do
    Map.take(dungeon, @copiable_dungeon_fields)
  end

  @doc """
  Creates a dungeon.

  ## Examples

      iex> create_dungeon(%{field: value})
      {:ok, %Dungeon{}}

      iex> create_dungeon(%{field: bad_value})
      {:error, %Ecto.Changeset{}}

  """
  def create_dungeon(attrs \\ %{}) do
    %Dungeon{}
    |> Dungeon.changeset(attrs)
    |> Repo.insert()
    |> _insert_line_identifier()
  end

  defp _insert_line_identifier({:ok, dungeon}) do
    if dungeon.line_identifier do
      {:ok, dungeon}
    else
      update_dungeon(dungeon, %{line_identifier: dungeon.id})
    end
  end
  defp _insert_line_identifier(error), do: error

  @doc """
  Creates a new version of an active dungeon. Returns an error if there exists a next version already.

  ## Examples

      iex> create_new_dungeon_version(%Dungeon{active: true})
      {:ok, %Dungeon{}}

      iex> create_new_dungeon_version(%Dungeon{active: false})
      {:error, "Inactive dungeon"}
  """
  def create_new_dungeon_version(%Dungeon{active: true} = dungeon) do
    unless next_version_exists?(dungeon) do
      case Multi.new
           |> Multi.insert(:new_dungeon_version, _dungeon_copy(dungeon))
           |> Multi.run(:new_levels, fn(_repo, %{new_dungeon_version: new_dungeon}) ->
                results = Repo.preload(dungeon, :levels).levels
                          |> Enum.map(fn(level) ->
                               _create_new_level_version(level, new_dungeon.id)
                             end)

                if Enum.any?(results, fn(result) -> Enum.at(Tuple.to_list(result), 0) == :error end) do
                  {:error, results}
                else
                  {:ok, results}
                end
              end)
            |> Repo.transaction() do

        {:ok, %{new_dungeon_version: new_dungeon}} -> {:ok, new_dungeon}

        errors -> errors
      end
    else
      {:error, "New version already exists"}
    end
  end

  def create_new_dungeon_version(%Dungeon{active: false} = _dungeon) do
    {:error, "Inactive dungeon"}
  end

  defp _create_new_level_version(%Level{} = level, dungeon_id) do
    Multi.new
    |> Multi.insert(:level, _level_copy_changeset(level, dungeon_id))
    |> Multi.run(:tiles, fn(_repo, %{level: new_level}) ->
        result = Repo.insert_all(Tile, _new_tile_copies(level, new_level.id))
        {:ok, result}
      end)
    |> Multi.run(:spawn_locations, fn(_repo, %{level: new_level}) ->
        result = Repo.insert_all(SpawnLocation, _new_spawn_locations(level, new_level.id))
        {:ok, result}
      end)
    |> Repo.transaction()
  end

  defp _dungeon_copy(dungeon) do
    attrs = Map.merge(copy_dungeon_fields(dungeon), %{version: dungeon.version+1, previous_version_id: dungeon.id})
    Dungeon.changeset(%Dungeon{}, attrs)
  end

  defp _level_copy_changeset(level, dungeon_id) do
    attrs = copy_level_fields(level)
    Level.changeset(%Level{}, Map.put(attrs, :dungeon_id, dungeon_id))
  end

  defp _new_tile_copies(previous_level, level_id) do
    Repo.preload(previous_level, :tiles).tiles
    |> Enum.map(fn(t) -> _new_tile_copy(t, level_id) end )
  end

  defp _new_tile_copy(t, level_id) do
    copy_tile_fields(t)
    |> Map.put(:level_id, level_id)
  end

  defp _new_spawn_locations(previous_level, level_id) do
    Repo.preload(previous_level, :spawn_locations).spawn_locations
    |> Enum.map(fn(sl) -> %{level_id: level_id, row: sl.row, col: sl.col} end)
  end

  @doc """
  Autogenerates a dungeon.

  ## Examples

      iex> generate_dungeon(DungeonGenerator, %{field: value})
      {:ok, %Dungeon{}}

      iex> generate_dungeon(DungeonGenerator, %{field: bad_value})
      {:error, %Ecto.Changeset{}}

  """
  def generate_dungeon(level_generator, dungeon_attrs \\ %{}, level_attrs \\ %{}, to_be_edited \\ false) do
    case create_dungeon(Map.merge(dungeon_attrs, %{autogenerated: !to_be_edited})) do
      {:ok, dungeon} ->
        level_attrs = Map.merge(level_attrs, %{autogenerated: !to_be_edited, dungeon_id: dungeon.id, entrance: true})
        case generate_level(level_generator, level_attrs) do
          {:ok, _} -> {:ok, dungeon}
          error -> error
        end
      error -> error
    end
  end

  @doc """
  Activates a dungeon.

  ## Examples

      iex> activate_dungeon(dungeon)
      {:ok, %Level{}}

      iex> activate_dungeon(dungeon)
      {:error, <error message>}

  """
  def activate_dungeon(%Dungeon{} = dungeon) do
    case _inactive_tiles(dungeon) do
      [] ->
        if dungeon.previous_version_id, do: delete_dungeon!(get_dungeon!(dungeon.previous_version_id))
        update_dungeon(dungeon, %{active: true})

      inactive_tile_list ->
        {:error, "Inactive tiles: #{ Enum.join(_inactive_tiles_error_msgs(inactive_tile_list), ", ") }"}
    end
  end

  defp _inactive_tiles(dungeon) do
    Repo.all(from l in Level,
             where: l.dungeon_id == ^dungeon.id,
             left_join: t in assoc(l, :tiles),
             left_join: tt in assoc(t, :tile_template),
             where: tt.active == false,
             group_by: tt.id,
             select: [tt.name, tt.id, count(tt.id)])
  end

  defp _inactive_tiles_error_msgs([[name, id, count] | tail]) do
    [ "#{name} (id: #{id}) #{count} times" | _inactive_tiles_error_msgs(tail) ]
  end

  defp _inactive_tiles_error_msgs(_empty), do: []

  @doc """
  Deletes a Dungeon.

  ## Examples

      iex> delete_dungeon(dungeon)
      {:ok, %Dungeon{}}

      iex> delete_dungeon(dungeon)
      {:error, %Ecto.Changeset{}}

  """
  def delete_dungeon(%Dungeon{} = dungeon) do
    change_dungeon(dungeon, %{deleted_at: NaiveDateTime.utc_now |> NaiveDateTime.truncate(:second)})
    |> Repo.update
  end
  def delete_dungeon!(%Dungeon{} = dungeon) do
    change_dungeon(dungeon, %{deleted_at: NaiveDateTime.utc_now |> NaiveDateTime.truncate(:second)})
    |> Repo.update!
  end

  @doc """
  Hard deletes a Dungeon.

  ## Examples

      iex> delete_dungeon(dungeon)
      %Level{}

      iex> delete_dungeon(dungeon)
      :error
  """
  def hard_delete_dungeon!(%Dungeon{} = dungeon) do
    Repo.preload(dungeon, :levels).levels
    |> Enum.each(fn(level) -> Repo.delete!(level) end)
    Repo.delete!(dungeon)
  end

  @doc """
  Returns an `%Ecto.Changeset{}` for tracking dungeon changes.

  ## Examples

      iex> change_dungeon(dungeon)
      %Ecto.Changeset{source: %Dungeon{}}

  """
  def change_dungeon(%Dungeon{} = dungeon, changes \\ %{}) do
    Dungeon.changeset(dungeon, changes)
  end

  @doc """
  Updates a Dungeon.

  ## Examples

      iex> update_dungeon(dungeon, %{field: new_value})
      {:ok, %Dungeon{}}

      iex> update_dungeon(dungeon, %{field: bad_value})
      {:error, %Ecto.Changeset{}}

  """
  def update_dungeon(%Dungeon{} = dungeon, attrs) do
    dungeon
    |> Dungeon.changeset(attrs)
    |> Repo.update()
  end

  @doc """
  Returns the list of levels for a Dungeon.

  ## Examples

      iex> list_levels(%Dungeon{})
      [%Level{}, ...]

  """
  def list_levels(%Dungeon{} = dungeon) do
    Repo.all(from l in Level,
             where: l.dungeon_id == ^dungeon.id)
  end

  @doc """
  Returns a list of levels with the player locations preloaded for the given dungeon.

  ## Examples

    iex> list_levels_with_player_count(%Dungeon{})
    [%{level: %Level{}, player_count: 4}, ...]
  """
  def list_levels_with_player_count(%Dungeon{} = dungeon) do
    Repo.all(from l in Level,
             where: l.dungeon_id == ^dungeon.id,
             left_join: li in assoc(l, :level_instances),
             left_join: t in assoc(li, :tiles),
             left_join: pmt in assoc(t, :player_location),
             preload: [locations: {l, locations: pmt}],
             select: %{level_id: l.id, level: l},
             order_by: [l.number, pmt.id])
  end

  @doc """
  Returns the next level number.

  ## Examples

    iex> next_level_number(%Dungeon{})
    2
  """
  def next_level_number(%Dungeon{} = dungeon) do
    case Repo.one(from d in Dungeon,
                  where: d.id == ^dungeon.id,
                  left_join: m in assoc(d, :levels),
                  select: max(m.number)) do
      nil -> 1
      num -> num + 1
    end
  end

  @doc """
  Gets a single level.

  Raises `Ecto.NoResultsError` if the Level does not exist.

  ## Examples

      iex> get_level!(123)
      %Level{}

      iex> get_level!(456)
      ** (Ecto.NoResultsError)

  """
  def get_level(id),  do: Repo.get(Level, id)
  def get_level!(id), do: Repo.get!(Level, id)

  def get_level(_dungeon_id, nil), do: nil
  def get_level(dungeon_id, level), do: Repo.get_by(Level, %{dungeon_id: dungeon_id, number: level})

  @doc """
  Returns a tuple containing the lowest z_index and highest z_index values, respectively.

  ## Examples

      iex> get_bounding_z_indexes!(456)
      {0,1}
  """
  def get_bounding_z_indexes(%Level{id: level_id}) do
    get_bounding_z_indexes(level_id)
  end
  def get_bounding_z_indexes(level_id) do
    Repo.one(from t in Tile,
             where: t.level_id == ^level_id,
             select: {min(t.z_index), max(t.z_index)})
  end

  @doc """
  Returns list of historic (ie, soft deleted) TileTemplates which are present in the level.
  These not selectable for new level design.

  ## Examples

      iex> list_historic_tile_templates(%Level{})
      [%TileTemplate{}, ...]
  """
  def list_historic_tile_templates(%Level{} = level) do
    Repo.all(from t in Tile,
             where: t.level_id == ^level.id,
             left_join: tt in assoc(t, :tile_template),
             where: not is_nil(tt.deleted_at),
             distinct: true,
             select: tt)
  end

  @doc """
  Returns a level of the copied level fields. Does not include the id or other record specific keys.

  ## Examples

      iex> copy_level_fields(%{id: 1, name: value, ...})
      %{name: value}

      iex> copy_level_fields(nil)
      %{}
  """
  def copy_level_fields(nil), do: %{}
  def copy_level_fields(dungeon) do
    Map.take(dungeon, @copiable_level_fields)
  end

  @doc """
  Creates a level.

  ## Examples

      iex> create_level(%{field: value})
      {:ok, %Level{}}

      iex> create_level(%{field: bad_value})
      {:error, %Ecto.Changeset{}}

  """
  def create_level(attrs \\ %{}) do
    %Level{}
    |> Level.changeset(attrs)
    |> Repo.insert()
  end

  @doc """
  Autogenerates a level. Must already have a level set, denoted by the dungeon_id in the attrs.

  ## Examples

      iex> generate_level(DungeonGenerator, %{field: value})
      {:ok, %Level{}}

      iex> generate_level(DungeonGenerator, %{field: bad_value})
      {:error, %Ecto.Changeset{}}

  """
  def generate_level(level_generator, attrs) do
    Multi.new
    |> Multi.insert(:level, Level.changeset(%Level{}, attrs))
    |> Multi.run(:tiles, fn(_repo, %{level: level}) ->
        result = Repo.insert_all(Tile, _generate_level_tiles(level, level_generator))
        {:ok, result}
      end)
    |> Repo.transaction()
  end

  defp _generate_level_tiles(level, level_generator) do
    tile_mapping = TileSeeder.basic_tiles()

    level_generator.generate(level.height, level.width)
    |> Enum.to_list
    |> Enum.map(fn({{row,col}, tile}) -> Map.merge(copy_tile_fields(tile_mapping[tile]),
                                                   %{level_id: level.id,
                                                     row: row,
                                                     col: col,
                                                     z_index: 0,
                                                     tile_template_id: tile_mapping[tile].id})
       end)
  end

  @doc """
  Updates a level.

  ## Examples

      iex> update_level(level, %{field: new_value})
      {:ok, %Level{}}

      iex> update_level(level, %{field: bad_value})
      {:error, %Ecto.Changeset{}}

  """
  def update_level(%Level{} = level, attrs) do
    case _update_level(level, attrs) do
      {:ok, updated_level} = result ->
        _adjust_sizing(level, updated_level)
        result
      error_result ->
        error_result
    end
  end

  defp _update_level(%Level{} = level, attrs) do
    level
    |> Level.changeset(attrs)
    |> Repo.update()
  end

  defp _adjust_sizing(level, updated_level) do
    Repo.delete_all(from sl in SpawnLocation,
                    where: sl.level_id == ^updated_level.id,
                    where: sl.col >= ^updated_level.width or sl.row >= ^updated_level.height )
    # probably should just use the main module looking for the space character. Character isn't index, but since it
    # is a seed it should have a low id and be found quick
    empty_tile_template = DungeonCrawl.TileTemplates.TileSeeder.rock_tile()
    # row, col are zero index
    # Crop first
    Repo.delete_all(from t in Tile,
                    where: t.level_id == ^updated_level.id,
                    where: t.col >= ^updated_level.width or t.row >= ^updated_level.height )
    # Empty fill second
    new_tiles = _dim_list_difference(level, updated_level)
                |> Enum.map(fn({row,col}) -> Map.merge(copy_tile_fields(empty_tile_template),
                                                       %{level_id: updated_level.id,
                                                         row: row,
                                                         col: col,
                                                         z_index: 0,
                                                         tile_template_id: empty_tile_template.id})
                  end)
    Repo.insert_all Tile, new_tiles
  end

  # less efficient to make two lists of dimensions and difference them, but less code than computing
  defp _dim_list_difference(level, updated_level) do
    _dim_list(updated_level.width, updated_level.height) -- _dim_list(level.width, level.height)
  end

  defp _dim_list(width, height) do
    for row <- Enum.to_list(0..height-1) do
      for col <- Enum.to_list(0..width-1) do
        {row, col}
      end
    end
    |> Enum.concat
  end

  @doc """
  Links the levels the given level is adjacent to (ie, number_north, etc). If the adjacent level
  is not already linked to the given level, the direction number field for it will be set to make
  the adjacency mutual. (Ie, a level west of level A will have level A assigned to its east)

  ## Examples

    iex> link_unlinked_levels(%Level{number: 1, number_north: 2})
    :ok
    # %Level{number: 2, number_south: 1} ...
  """
  def link_unlinked_levels(level) do
    [[:number_north, :number_south], [:number_south, :number_north], [:number_east, :number_west], [:number_west, :number_east]]
    |> Enum.each(fn [direction, opposite] ->
         with adj_number when not is_nil(adj_number) <- Map.get(level, direction),
              adj_level when not is_nil(adj_level) <- get_level(level.dungeon_id, adj_number),
              nil <- Map.get(adj_level, opposite) do
           update_level(adj_level, %{opposite => level.number})
         end
       end)

    :ok
  end

  @doc """
  Deletes a Level. This is not reversible, as it is not a soft delete.

  ## Examples

      iex> delete_level(level)
      {:ok, %Level{}}

      iex> delete_level(level)
      {:error, %Ecto.Changeset{}}

  """
  def delete_level(%Level{} = level) do
    Repo.delete(level)
  end
  def delete_level!(%Level{} = level) do
    Repo.delete!(level)
  end

  @doc """
  Returns an `%Ecto.Changeset{}` for tracking level changes.

  ## Examples

      iex> change_level(level)
      %Ecto.Changeset{source: %Level{}}

  """
  def change_level(%Level{} = level, changes \\ %{}) do
    Level.changeset(level, changes)
  end

  @doc """
  Returns a map of the direction (key) and displayable version of the adjacent level number and name (value).
  """
  def adjacent_level_names(%Level{} = level) do
    %{ north: _extract_adjacent_level_name(get_level(level.dungeon_id, level.number_north)),
       south: _extract_adjacent_level_name(get_level(level.dungeon_id, level.number_south)),
       east: _extract_adjacent_level_name(get_level(level.dungeon_id, level.number_east)),
       west: _extract_adjacent_level_name(get_level(level.dungeon_id, level.number_west))}
  end

  defp _extract_adjacent_level_name(nil), do: nil
  defp _extract_adjacent_level_name(adjacent) do
    "#{adjacent.number} - #{adjacent.name}"
  end

  @doc """
  Returns a map of the direction (key) and the edge tiles of the adjacent level. For example,
  the level adjacent to the west will return the tiles on its eastern edge.
  """
  def adjacent_level_edge_tiles(%Level{} = level) do
    ["north", "south", "east", "west"]
    |> Enum.map(fn direction -> adjacent_level_edge_tile(level, direction) end)
    |> Enum.reduce(%{}, &Map.merge/2)
  end

  def adjacent_level_edge_tile(%Level{} = level, "north"), do: %{ north: level_edge_tiles(get_level(level.dungeon_id, level.number_north), "south") }
  def adjacent_level_edge_tile(%Level{} = level, "south"), do: %{ south: level_edge_tiles(get_level(level.dungeon_id, level.number_south), "north") }
  def adjacent_level_edge_tile(%Level{} = level, "east"),  do: %{ east: level_edge_tiles(get_level(level.dungeon_id, level.number_east), "west") }
  def adjacent_level_edge_tile(%Level{} = level, "west"),  do: %{ west: level_edge_tiles(get_level(level.dungeon_id, level.number_west), "east") }

  def level_edge_tiles(_level, _edge, select \\ [:row, :col, :character, :color, :background_color])
  def level_edge_tiles(nil, _edge, _select), do: nil
  def level_edge_tiles(_level, nil, _select), do: nil
  def level_edge_tiles(%Level{} = level, edge, select) do
    edge = case edge do
             "north" -> [row: 0]
             "south" -> [row: level.height - 1]
             "east"  -> [col: level.width - 1]
             "west"  -> [col: 0]
           end

    Repo.all(from t in Tile,
             where: t.level_id == ^level.id,
             where: ^edge,
             select: ^select)
  end

  @doc """
  Gets a single tile, with the highest z_index for given coordinates (if no z_index is given)

  Raises `Ecto.NoResultsError` if the Level tile does not exist.

  ## Examples

      iex> get_tile!(123)
      %Tile{}

      iex> get_tile!(456)
      ** (Ecto.NoResultsError)

  """
  def get_tile!(%{level_id: level_id, row: row, col: col, z_index: z_index}), do: get_tile!(level_id, row, col, z_index)
  def get_tile!(%{level_id: level_id, row: row, col: col}), do: get_tile!(level_id, row, col)
  def get_tile!(id), do: Repo.get!(Tile, id)
  def get_tile!(level_id, row, col, z_index) do
    Repo.one!(_get_tile_query(level_id, row, col, z_index, 1))
  end
  def get_tile!(level_id, row, col) do
    Repo.one!(_get_tile_query(level_id, row, col, 1))
  end

  def get_tile(%{level_id: level_id, row: row, col: col, z_index: z_index}), do: get_tile(level_id, row, col, z_index)
  def get_tile(%{level_id: level_id, row: row, col: col}), do: get_tile(level_id, row, col)
  def get_tile(level_id, row, col, z_index) do
    Repo.one(_get_tile_query(level_id, row, col, z_index, 1))
  end
  def get_tile(level_id, row, col) do
    Repo.one(_get_tile_query(level_id, row, col, 1))
  end

  @doc """
  Returns an array of tiles from high to low z_index.

  ## Examples

      iex> get_tiles(103, 14, 56)
      [%Tile{}, %Tile{}, ...]

      iex> get_tiles(%{level_id: 103, row: 14, col: 56})
      []
  """
  def get_tiles(%{level_id: level_id, row: row, col: col}), do: get_tiles(level_id, row, col)
  def get_tiles(level_id, row, col) do
    Repo.all(_get_tile_query(level_id, row, col, nil))
  end

  defp _get_tile_query(level_id, row, col, z_index, max_results) do
    from t in Tile,
    where: t.level_id == ^level_id and t.row == ^row and t.col == ^col and t.z_index == ^z_index,
    limit: ^max_results
  end

  defp _get_tile_query(level_id, row, col, max_results) do
    from t in Tile,
    where: t.level_id == ^level_id and t.row == ^row and t.col == ^col,
    order_by: [desc: :z_index],
    limit: ^max_results
  end

  @doc """
  Copies a tile and returns a map of the copied fields. Does not include the id or other record specific keys.

  ## Examples

      iex> create_tile(%{field: value})
      {:ok, %Tile{}}

      iex> create_tile(%{field: bad_value})
      {:error, %Ecto.Changeset{}}
  """
  def copy_tile_fields(nil), do: %{}
  def copy_tile_fields(tile) do
    Map.take(tile, @copiable_tile_fields)
  end

  @doc """
  Creates a tile.

  ## Examples

      iex> create_tile(%{field: value})
      {:ok, %Tile{}}

      iex> create_tile(%{field: bad_value})
      {:error, %Ecto.Changeset{}}

  """
  def create_tile(attrs \\ %{}) do
    %Tile{}
    |> Tile.changeset(attrs)
    |> Repo.insert()
  end
  def create_tile!(attrs \\ %{}) do
    %Tile{}
    |> Tile.changeset(attrs)
    |> Repo.insert!()
  end

  @doc """
  Updates a tile.

  ## Examples

      iex> update_tile(tile, %{field: new_value})
      {:ok, %Tile{}}

      iex> update_tile(tile, %{field: bad_value})
      {:error, %Ecto.Changeset{}}

  """
  def update_tile!(%Tile{} = tile, attrs) do
    tile
    |> Tile.changeset(attrs)
    |> Repo.update!
  end
  def update_tile!(%{level_id: level_id, row: row, col: col}, attrs) do
    update_tile!(get_tile!(level_id, row, col), attrs)
  end

  def update_tile(%Tile{} = tile, attrs) do
    tile
    |> Tile.changeset(attrs)
    |> Repo.update
  end
  def update_tile(%{level_id: level_id, row: row, col: col}, attrs) do
    update_tile(get_tile!(level_id, row, col), attrs)
  end


  @doc """
  Returns the number of Tiles that reference a given tile template.

  ## Examples

      iex> tile_template_reference_count(tile_template)
      4

      iex> tile_template_reference_count(6)
      0

  """
  def tile_template_reference_count(%TileTemplate{} = tile_template) do
    tile_template_reference_count(tile_template.id)
  end
  def tile_template_reference_count(tile_template_id) do
    Repo.one(from t in Tile, select: count(t.id), where: t.tile_template_id == ^tile_template_id)
  end

  @doc """
  Returns an `%Ecto.Changeset{}` for tracking tile changes.

  ## Examples

      iex> change_tile(tile)
      %Ecto.Changeset{source: %Tile{}}

  """
  def change_tile(%Tile{} = tile) do
    Tile.changeset(tile, %{})
  end

  @doc """
  Deletes a Tile. If the tile with the given coords and level does not exist, nil is returned.

  ## Examples

      iex> delete_tile(%Tile{})
      %Tile{}

      iex> delete_tile(level_id, row, col, z_index)
      %Tile{}

      iex> delete_level(level_id, row, col, z_index)
      nil
  """
  def delete_tile(level_id, row, col, z_index) do
    delete_tile(get_tile(level_id, row, col, z_index))
  end
  def delete_tile(nil), do: nil
  def delete_tile(%Tile{} = tile) do
    Repo.delete(tile)
  end

  @doc """
  Adds spawn locations for the given level. Uses a list of {row, col} tuples to indicate the new
  spawn coordinates. Existing spawn locations as well as invalid coordinates are ignored.

  ## Examples

      iex> add_spawn_locations(%Level{}, [{row, col}, ...])
      [%SpawnLocation{}, ...]
  """
  def add_spawn_locations(level_id, coordinates) do
    level = get_level!(level_id)

    Multi.new
    |> Multi.run(:spawn_locations, fn(_repo, %{}) ->
        locations = coordinates
                    |> Enum.uniq
                    |> Enum.map(fn({row, col}) -> %{level_id: level_id, row: row, col: col} end)
                    |> Enum.reject(fn(attrs) -> Repo.get_by(SpawnLocation, level_id: attrs.level_id, row: attrs.row, col: attrs.col) end) # TODO: remove after pg local updated
                    |> Enum.filter(fn(attrs) ->
                        SpawnLocation.changeset(%SpawnLocation{}, attrs, level.height, level.width).valid?
                       end)
        # result = Repo.insert_all(SpawnLocation, locations, on_conflict: :nothing, conflict_target: "spawn_locations_dungeon_id_row_col_index") # TODO: use after pg local updated - might need to update the index name for consistency as well, there could also be other index names to update
        result = Repo.insert_all(SpawnLocation, locations)
        {:ok, result}
      end)
    |> Repo.transaction()
  end

  @doc """
  Deletes all the spawn locations for the given level.

  ## Examples

      iex> clear_spawn_locations(%Level{}, [{row, col}, ...])
      [%SpawnLocation{}, ...]
  """
  def clear_spawn_locations(level_id) do
    Repo.delete_all(from s in SpawnLocation,
                    where: s.level_id == ^level_id)
  end

  @doc """
  Sets the spawn locations for the given level. Uses a list of {row, col} tuples to indicate the new
  spawn coordinates. Existing spawn locations are first removed, and then the new list is added.

  ## Examples

      iex> set_spawn_locations(%Level{}, [{row, col}, ...])
      [%SpawnLocation{}, ...]
  """
  def set_spawn_locations(level_id, coordinates) do
    clear_spawn_locations(level_id)
    add_spawn_locations(level_id, coordinates)
  end
end
