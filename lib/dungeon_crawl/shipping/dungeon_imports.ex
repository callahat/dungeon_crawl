defmodule DungeonCrawl.Shipping.DungeonImports do
  @moduledoc """
  The Dungeon Importer module. Its goal is to take an exported dungeon representation,
  generated by DungeonExports, and find or create all tile templates, sounds, and items, as
  well as the dungeon, its levels, and all the associated tiles. Temporary ID's and temporary
  slugs will be replaced with the proper found or created ones. If assets are created (since
  they did not exist or were not useable by the user running the import) they will be set
  to private and owned by the importing user.
  """

  alias DungeonCrawl.Shipping.DungeonExports
  alias DungeonCrawl.Shipping.AssetImport

  alias DungeonCrawl.Equipment
  alias DungeonCrawl.Sound
  alias DungeonCrawl.TileTemplates

  alias DungeonCrawl.Repo

  use DungeonCrawl.Shipping.SlugMatching

  import Ecto.Query
  import DungeonCrawl.Shipping.Private.ImportFunctions

  # is this struct used? doesnt seem so
  defstruct dungeon: nil,
            levels: %{},
            tiles: %{},
            items: %{},
            tile_templates: %{},
            sounds: %{}

  def run(%DungeonExports{} = export, user, import_id, line_identifier) do
    # do something different if this import is in progress and there were ambiguous matches resolved
    export = log_time(export, "Start: ")
             |> find_or_create_assets(import_id, :sounds, user)
             |> find_or_create_assets(import_id, :items, user)
             |> find_or_create_assets(import_id, :tile_templates, user)
             |> _break_if_waiting_on_asset_imports(import_id)
    # at this point, bail if there are ambiguous matches that are unresolved
             |> create_and_add_slugs_to_built_assets(:sounds)
             |> create_and_add_slugs_to_built_assets(:items)
             |> create_and_add_slugs_to_built_assets(:tile_templates)
             |> swap_scripts_to_tmp_scripts(:tiles)
             |> repoint_ttids_and_slugs(:tiles)
             |> repoint_ttids_and_slugs(:items)
             |> repoint_ttids_and_slugs(:tile_templates)
             |> repoint_dungeon_starting_items()
             |> set_dungeon_overrides(user.id, line_identifier)
             |> maybe_handle_previous_version()
             |> create_dungeon()
             |> create_levels()
             |> create_spawn_locations()
             |> complete_dungeon_import()
             |> log_time("End: ")

    export
  end

  defp _break_if_waiting_on_asset_imports(export, import_id) do
    if Repo.exists?(from ai in AssetImport,
                    where: ai.dungeon_import_id == ^import_id and
                           ai.action != :resolved) do
      %{ export | status: "halt" }
    else
      export
    end
  end

  @doc """
  Attempt to lookup an existing asset import by either the temporary slug from the
  import data.

  ## Examples

      iex> get_asset_import(import_id, "item", "tmp_item_id_0")
      nil
      iex> get_asset_import(import_id, "item", "tmp_item_id_1")
      %AssetImport{}
      iex> get_asset_import(import_id, asset_import_id)
      %AssetImport{}
  """
  def get_asset_import(import_id, asset_import_id) do
    Repo.one(from ai in AssetImport, where: ai.dungeon_import_id == ^import_id and
                                            ai.id == ^asset_import_id)
  end

  def get_asset_import(import_id, type, tmp_slug) do
    Repo.one(from ai in AssetImport, where: ai.dungeon_import_id == ^import_id and
                                            ai.type == ^type and
                                            ai.importing_slug == ^tmp_slug)
  end

  @doc """
  Returns a list of the asset imports for the given dungeon import id.
  Includes the existing slug match record.
  """
  def get_asset_imports(import_id) do
    Repo.all(from ai in AssetImport,
             where: ai.dungeon_import_id == ^import_id)
  end

  def get_asset_imports(import_id, :unresolved) do
    Repo.all(from ai in AssetImport,
             where: ai.dungeon_import_id == ^import_id and
                    ai.action != :resolved)
  end

  @doc """
  Creates the asset import. Raises an exception if invalid.

  ## Examples

      iex> create_asset_import(123, "item", "tmp_item_1", "box", %{}, %{})
      %AssetImport{}
  """
  def create_asset_import!(import_id, type, tmp_slug, existing_slug, attrs, existing_attrs) do
    %AssetImport{}
    |> AssetImport.changeset(%{
         dungeon_import_id: import_id,
         type: type,
         importing_slug: tmp_slug,
         existing_slug: existing_slug,
         attributes: attrs,
         existing_attributes: existing_attrs
       })
    |> Repo.insert!()
  end

  @doc """
  Finds or creates an asset import. Since this is intended to be called
  by the system any AssetImport validation error raises an exception.

  ## Examples

      iex> find_or_create_asset_import!(123, "item", "tmp_item_id_0", "item_123", %{}, %{})
      %AssetImport{}
      iex> find_or_create_asset_import!(123, "bad_type", "tmp_item_id_1", "item_123", %{}, %{})
      ** (Ecto.InvalidChangesetError)
  """
  def find_or_create_asset_import!(import_id, type, tmp_slug, existing_slug, attrs, existing_attrs) do
    case get_asset_import(import_id, type, tmp_slug) do
      nil ->
        create_asset_import!(import_id, type, tmp_slug, existing_slug, attrs, existing_attrs)

      asset_import ->
        asset_import
    end
  end

  @doc """
  Update the asset import record.
  """
  def update_asset_import!(%AssetImport{} = asset, attributes) do
    asset
    |> AssetImport.update_changeset(attributes)
    |> Repo.update!()
  end

  @doc """
  Gets the resolved asset.
  """
  def get_resolved_asset!(%{resolved_slug: nil}) do
    raise __MODULE__.AssetImportNotResolved
  end
  def get_resolved_asset!(%AssetImport{action: :resolved, type: :items} = import) do
    Equipment.get_item!(import.resolved_slug)
  end
  def get_resolved_asset!(%AssetImport{action: :resolved, type: :sounds} = import) do
    Sound.get_effect!(import.resolved_slug)
  end
  def get_resolved_asset!(%AssetImport{action: :resolved, type: :tile_templates} = import) do
    TileTemplates.get_tile_template!(import.resolved_slug, :validation)
  end
  def get_resolved_asset!(%{action: action}) do
    raise __MODULE__.AssetImportNotResolved, "Cannot get resolved asset when action is #{ action }"
  end

  defmodule AssetImportNotResolved do
    defexception message: "Cannot get resolved asset"
  end
end
