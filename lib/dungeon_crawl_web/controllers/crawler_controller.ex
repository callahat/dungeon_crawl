defmodule DungeonCrawlWeb.CrawlerController do
  use DungeonCrawl.Web, :controller

  alias DungeonCrawlWeb.{Dungeon,DungeonMapTile,PlayerLocation}
  alias DungeonCrawl.DungeonGenerator
  alias Ecto.Multi

  plug :assign_player_location when action in [:show, :create, :destroy]
  plug :validate_not_crawling  when action in [:create]

  @dungeon_generator Application.get_env(:dungeon_crawl, :generator) || DungeonGenerator

#  def index(conn, _params) do
#    render(conn, "index.html", crawler: crawler)
#  end

  def show(conn, _opts) do
    player_location = conn.assigns[:player_location]

    render(conn, "show.html", player_location: player_location)
  end

  def create(conn, _opts) do
    dungeon_changeset = 
      Dungeon.changeset(%Dungeon{}, %{name: "Autogenerated", width: 80, height: 40}) 
      |> Ecto.Changeset.put_change(:autogenerated, true)

    Multi.new
    |> Multi.insert(:dungeon, dungeon_changeset)
    |> Multi.run(:dungeon_map_tiles, fn(%{dungeon: dungeon}) ->
        result = Repo.insert_all(DungeonMapTile, Dungeon.generate_dungeon_map_tiles(dungeon, @dungeon_generator))
        {:ok, result}
      end)
    |> Multi.run(:player_location, fn(%{dungeon: dungeon}) ->
        empty_floor = Repo.preload(dungeon, :dungeon_map_tiles).dungeon_map_tiles
                      |> Enum.filter(fn(t) -> t.tile == "." end)
                      |> Enum.random
        result = PlayerLocation.changeset(%PlayerLocation{}, %{dungeon_id: dungeon.id,row: empty_floor.row, col: empty_floor.col, user_id_hash: conn.assigns[:user_id_hash]})
                 |> Repo.insert!
        {:ok, result}
      end)
    |> Repo.transaction
    |> case do
      {:ok, %{dungeon: _dungeon}} ->
        conn
        |> put_flash(:info, "Dungeon created successfully.")
        |> redirect(to: crawler_path(conn, :show))
      # This will probably not be encountered, as the autogenerated dungeon won't have bad user input
      {:error, op, _res, _others} ->
        conn
        |> put_flash(:error, "Something went wrong with '#{op}'")
        |> render("show.html")
    end
  end

  def destroy(conn, _opts) do
    player_location = Repo.get_by(PlayerLocation, %{user_id_hash: conn.assigns[:user_id_hash]})
                      |> Repo.preload(:dungeon)
    
    Repo.delete!(player_location)
    if player_location.dungeon.autogenerated, do: Repo.delete!(player_location.dungeon)

    conn
    |> put_flash(:info, "Dungeon cleared.")
    |> redirect(to: crawler_path(conn, :show))
  end

  defp assign_player_location(conn, _opts) do
    player_location = Repo.get_by(PlayerLocation, %{user_id_hash: conn.assigns[:user_id_hash]})
                      |> Repo.preload(dungeon: :dungeon_map_tiles)
    conn
    |> assign(:player_location, player_location)
  end

  defp validate_not_crawling(conn, _opts) do
    if conn.assigns.player_location == nil do
      conn
    else
      conn
      |> put_flash(:info, "Already crawling dungeon")
      |> redirect(to: crawler_path(conn, :show))
      |> halt()
    end
  end
end
