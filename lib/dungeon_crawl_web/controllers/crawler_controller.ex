defmodule DungeonCrawlWeb.CrawlerController do
  use DungeonCrawl.Web, :controller

  alias DungeonCrawl.Account
  alias DungeonCrawl.Account.User
  alias DungeonCrawl.Admin
  alias DungeonCrawl.Player
  alias DungeonCrawl.Dungeon
  alias DungeonCrawl.DungeonInstances
  alias DungeonCrawl.DungeonProcesses.Player, as: PlayerInstance
  alias DungeonCrawl.MapGenerators.ConnectedRooms
  alias Ecto.Multi

  import DungeonCrawlWeb.Crawler, only: [join_and_broadcast: 4, leave_and_broadcast: 1]

  plug :assign_player_location when action in [:show, :create, :avatar, :validate_avatar, :invite, :validate_invite, :destroy]
  plug :validate_not_crawling  when action in [:create, :avatar, :validate_avatar, :invite, :validate_invite]
  plug :validate_passcode when action in [:invite, :validate_invite]
  plug :validate_active_or_owner when action in [:avatar, :validate_avatar]
  plug :validate_autogen_solo_enabled when action in [:create]
  plug :validate_instance_limit when action in [:invite, :avatar, :validate_avatar]

  @dungeon_generator Application.get_env(:dungeon_crawl, :generator) || ConnectedRooms

  def show(conn, _opts) do
    player_location = conn.assigns[:player_location]

    map_sets = if player_location,
                 do: [],
                 else: Dungeon.list_active_map_sets_with_player_count()
                       |> Enum.map(fn(%{map_set: map_set}) -> Repo.preload(map_set, [:dungeons, :locations, :map_set_instances]) end)
    map_set = if player_location, do: Repo.preload(player_location, [map_tile: [dungeon: :map_set]]).map_tile.dungeon.map_set,
                                  else: nil

    player_stats = if player_location do
                     PlayerInstance.current_stats(player_location.user_id_hash)
                   else
                     %{}
                   end

    render(conn, "show.html", player_location: player_location, map_sets: map_sets, player_stats: player_stats, map_set: map_set)
  end

  def avatar(conn, params) do
    params = Map.take(params, ["map_set_id", "map_set_instance_id", "is_private", "passcode"])
    if user = (get_session(conn, :user_avatar) || Account.get_by_user_id_hash(conn.assigns[:user_id_hash])) do
      user = Map.to_list(user)
             |> Enum.map(fn {k, v} -> {to_string(k), v} end)
             |> Enum.into(%{})
             |> Map.take(["name", "color", "background_color"])
      conn
      |> assign(:user, user)
      |> join(params)
    else
      user = %{"name" => "AnonPlayer", "color" => %User{}.color, "background_color" => %User{}.background_color}
      action_path = action_path(conn, params)
      render(conn, "avatar.html", user: user, action_path: action_path)
    end
  end

  def validate_avatar(conn, %{"user" => user} = params) do
    if User.colors_match?(%{color: user["color"], background_color: user["background_color"]}) do
      params = Map.take(conn.query_params, ["map_set_id", "map_set_instance_id", "is_private", "passcode"])
               |> Map.merge(Map.take(params, ["map_set_id", "map_set_instance_id", "is_private", "passcode"]))
      action_path = action_path(conn, params)
      conn
      |> assign(:query_params, params)
      |> put_flash(:error, "Color and Background Color must be different")
      |> render("avatar.html", user: user, action_path: action_path)
    else
      conn
      |> put_session(:user_avatar, user)
      |> assign(:user, user)
      |> join(params)
    end
  end

  def create(conn, _opts) do
    dungeon_attrs = (%{name: "Autogenerated", width: Admin.get_setting.autogen_width, height: Admin.get_setting.autogen_height})

    # TODO: revisit multi's and clean this up
    Multi.new
    |> Multi.run(:map_set, fn(_repo, %{}) ->
        Dungeon.generate_map_set(@dungeon_generator, %{name: "Autogenerated", autogenerated: true}, dungeon_attrs)
      end)
    |> Multi.run(:map_set_instance, fn(_repo, %{map_set: map_set}) ->
        DungeonInstances.create_map_set(map_set)
      end)
    |> Multi.run(:player_location, fn(_repo, %{map_set: map_set}) ->
        # TODO: change this to only use stuff from the entrances
        map_set_instance = Enum.at(Repo.preload(map_set, :map_set_instances).map_set_instances, 0)
        Player.create_location_on_spawnable_space(map_set_instance, conn.assigns[:user_id_hash], %{})
      end)
    |> Repo.transaction
    |> case do
      {:ok, %{map_set: _map_set}} ->
        conn
        |> redirect(to: Routes.crawler_path(conn, :show))
    end
  end

  def invite(conn, %{"map_set_instance_id" => _msi_id, "passcode" => _passcode} = params) do
    avatar(conn, params)
  end

  def validate_invite(conn, %{"user" => _user} = params) do
    validate_avatar(conn, params)
  end

  def destroy(conn, _opts) do
    location = Player.get_location(conn.assigns[:user_id_hash])

    if location do
      map_set = Player.get_map_set(location)
      post_leave_path = if map_set.active || map_set.autogenerated, do: Routes.crawler_path(conn, :show), else: Routes.dungeon_path(conn, :show, map_set)

      leave_and_broadcast(location)

      conn
      |> put_flash(:info, "Dungeon cleared.")
      |> redirect(to: post_leave_path)
    else
      conn
      |> redirect(to: Routes.crawler_path(conn, :show))
    end
  end

  defp assign_player_location(conn, _opts) do
    # TODO: get this from the instance?
    player_location = Player.get_location(conn.assigns[:user_id_hash])
                      |> Repo.preload(map_tile: [:dungeon])

    conn
    |> assign(:player_location, player_location)
  end

  defp validate_not_crawling(conn, _opts) do
    if conn.assigns.player_location == nil do
      conn
    else
      conn
      |> put_flash(:error, "Already crawling dungeon")
      |> redirect(to: Routes.crawler_path(conn, :show))
      |> halt()
    end
  end

  defp validate_passcode(%{params: %{"map_set_instance_id" => msi_id, "passcode" => passcode}} = conn, _opts) do
    map_set_instance = DungeonInstances.get_map_set(msi_id)
    map_set_instance = if map_set_instance, do: Repo.preload(map_set_instance, :map_set), else: nil

    cond do
      is_nil(map_set_instance) ||
          map_set_instance.autogenerated ||
          map_set_instance.map_set.deleted_at ||
          map_set_instance.passcode != passcode ->
        conn
        |> put_flash(:error, "Cannot join that instance")
        |> redirect(to: Routes.crawler_path(conn, :show))
        |> halt()
      # todo: check for max players in instance -> cannot join, but ok to let them know the info is correct
      true ->
        conn
        |> assign(:map_set, map_set_instance)
    end
  end

  defp validate_active_or_owner(%{params: %{"map_set_id" => map_set_id}} = conn, _opts) do
    map_set = Dungeon.get_map_set(map_set_id)

    if map_set && !map_set.deleted_at && (map_set.active ||
        (conn.assigns.current_user && map_set.user_id == conn.assigns.current_user.id)) do #|| conn.assigns.current_user.is_admin
      conn
      |> assign(:map_set, map_set)
    else
      conn
      |> put_flash(:error, "Cannot join that dungeon")
      |> redirect(to: Routes.crawler_path(conn, :show))
      |> halt()
    end
  end

  defp validate_active_or_owner(%{params: %{"map_set_instance_id" => msi_id}} = conn, _opts) do
    map_set_instance = Repo.preload(DungeonInstances.get_map_set!(msi_id), :map_set)

    if map_set_instance && !map_set_instance.map_set.deleted_at && map_set_instance.map_set.active && !map_set_instance.is_private do #|| conn.assigns.current_user.is_admin
      conn
      |> assign(:instance, map_set_instance)
    else
      conn
      |> put_flash(:error, "Cannot join that instance")
      |> redirect(to: Routes.crawler_path(conn, :show))
      |> halt()
    end
  end

  defp validate_autogen_solo_enabled(conn, _opts) do
    if Admin.get_setting.autogen_solo_enabled do
      conn
    else
      conn
      |> put_flash(:error, "Generate and go solo is disabled")
      |> redirect(to: Routes.crawler_path(conn, :show))
      |> halt()
    end
  end

  defp validate_instance_limit(%{params: %{"map_set_id" => map_set_id}} = conn, _opts) do
    if is_nil(Admin.get_setting.max_instances) or Dungeon.instance_count(map_set_id) < Admin.get_setting.max_instances do
      conn
    else
      conn
      |> put_flash(:error, "Dungeon has reached its limit on instances and cannot create another")
      |> redirect(to: Routes.crawler_path(conn, :show))
      |> halt()
    end
  end
  defp validate_instance_limit(conn, _opts), do: conn

  defp join(conn, params) do
    join_target = cond do
                    params["passcode"] -> :map_set
                    params["map_set_instance_id"] -> :instance
                    true -> :map_set
                  end

    join_and_broadcast(conn.assigns[join_target], conn.assigns[:user_id_hash], conn.assigns[:user], !!params["is_private"])

    conn
    |> redirect(to: Routes.crawler_path(conn, :show))
  end

  defp action_path(conn, params) do
    cond do
      params["passcode"] -> Routes.crawler_path(conn, :validate_invite, params["map_set_instance_id"], params["passcode"], params)
      true -> Routes.crawler_path(conn, :validate_avatar, params)
    end
  end
end
