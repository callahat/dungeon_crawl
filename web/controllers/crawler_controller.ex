defmodule DungeonCrawl.CrawlerController do
  use DungeonCrawl.Web, :controller

  alias DungeonCrawl.{Dungeon,DungeonGenerator,DungeonMapTile,PlayerLocation}
  alias Ecto.Multi

  @dungeon_generator Application.get_env(:dungeon_crawl, :generator) || DungeonGenerator

#  def index(conn, _params) do
#    render(conn, "index.html", crawler: crawler)
#  end

  def show(conn, _opts) do
    player_location = Repo.get_by(PlayerLocation, %{user_id_hash: conn.assigns[:user_id_hash]}) 
                      |> Repo.preload(dungeon: :dungeon_map_tiles)

    if(player_location == nil || player_location.dungeon == nil) do
      render(conn, "show.html", dungeon_render: nil)
    else
      # render and listen.
      dungeon_render = 
      player_location.dungeon.dungeon_map_tiles
      |> Enum.sort(fn(a,b) -> {a.row, a.col} < {b.row, b.col} end)
      |> Enum.map(fn(row) -> row.tile end)
      |> to_charlist
      |> List.replace_at(player_location.row * player_location.dungeon.width + player_location.col, ?@)
      |> Enum.chunk(player_location.dungeon.width)
      |> Enum.join("\n")
      render(conn, "show.html", dungeon: player_location.dungeon, dungeon_render: dungeon_render)
    end
  end

  def create(conn, _opts) do
    player_location = Repo.get_by(PlayerLocation, %{user_id_hash: conn.assigns[:user_id_hash]}) 
                      |> Repo.preload(dungeon: :dungeon_map_tiles)

    if(player_location == nil || player_location.dungeon == nil) do
		  dungeon_changeset = 
		    Dungeon.changeset(%Dungeon{}, %{name: "Autogenerated", width: 80, height: 40}) 
		    |> Ecto.Changeset.put_change(:autogenerated, true)

		  Multi.new
		  |> Multi.insert(:dungeon, dungeon_changeset)
		  |> Multi.run(:dungeon_map_tiles, fn(%{dungeon: dungeon}) ->
		      result = Repo.insert_all(DungeonMapTile, Dungeon.generate_dungeon_map_tiles(dungeon, @dungeon_generator))
		      {:ok, result}
		    end)
		  |> Multi.run(:player_location, fn(%{dungeon: dungeon}) ->
		      empty_floor = Repo.preload(dungeon, :dungeon_map_tiles).dungeon_map_tiles
		                    |> Enum.filter(fn(t) -> t.tile == "." end)
		                    |> Enum.random
		      result = PlayerLocation.changeset(%PlayerLocation{}, %{dungeon_id: dungeon.id,row: empty_floor.row, col: empty_floor.col, user_id_hash: conn.assigns[:user_id_hash]})
		               |> Repo.insert!
		      {:ok, result}
		    end)
		  |> Repo.transaction
		  |> case do
		    {:ok, %{dungeon: _dungeon}} ->
		      conn
		      |> put_flash(:info, "Dungeon created successfully.")
		      |> redirect(to: crawler_path(conn, :show))
		    # This will probably not be encountered, as the autogenerated dungeon won't have bad user input
		    {:error, op, _res, _others} ->
		      conn
		      |> put_flash(:error, "Something went wrong with '#{op}'")
		      |> render("show.html")
		  end
    else
      conn
      |> put_flash(:info, "Already crawling dungeon")
		  |> redirect(to: crawler_path(conn, :show))
    end
  end
  

  def act(conn, _opts) do
#    changeset = Crawler.changeset(%Crawler{}, crawler_params)

#    case Repo.insert(changeset) do
#      {:ok, _crawler} ->
        conn
        |> redirect(to: crawler_path(conn, :show))
#      {:error, changeset} ->
#        render(conn, "new.html", changeset: changeset)
#    end
  end

  def destroy(conn, _opts) do
    player_location = Repo.get_by(PlayerLocation, %{user_id_hash: conn.assigns[:user_id_hash]})
                      |> Repo.preload(:dungeon)
    
    Repo.delete!(player_location)
    if player_location.dungeon.autogenerated, do: Repo.delete!(player_location.dungeon)

    conn
    |> put_flash(:info, "Dungeon cleared.")
    |> redirect(to: crawler_path(conn, :show))
  end
end
