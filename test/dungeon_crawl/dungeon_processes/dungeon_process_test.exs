defmodule DungeonCrawl.DungeonProcessTest do
  use DungeonCrawl.DataCase

  alias DungeonCrawl.Account.User
  alias DungeonCrawl.Dungeons
  alias DungeonCrawl.DungeonInstances
  alias DungeonCrawl.DungeonProcesses.Levels
  alias DungeonCrawl.DungeonProcesses.LevelProcess
  alias DungeonCrawl.DungeonProcesses.DungeonProcess
  alias DungeonCrawl.DungeonProcesses.LevelRegistry
  alias DungeonCrawl.DungeonInstances.Tile
  alias DungeonCrawl.Player.Location

  setup do
    dungeon_process = start_supervised!(DungeonProcess)

    dungeon_instance = insert_stubbed_dungeon_instance(%{}, %{}, [[%Tile{character: "O", row: 1, col: 1, z_index: 0}]])

    %{dungeon_process: dungeon_process, dungeon_instance: dungeon_instance}
  end

  test "scorable?", %{dungeon_process: dungeon_process} do
    DungeonProcess.set_dungeon(dungeon_process, %{autogenerated: false, active: true})
    DungeonProcess.set_state_value(dungeon_process, :no_scoring, true)
    refute DungeonProcess.scorable?(dungeon_process)

    DungeonProcess.set_state_value(dungeon_process, :no_scoring, false)
    assert DungeonProcess.scorable?(dungeon_process)

    DungeonProcess.set_state_value(dungeon_process, :no_scoring, nil)
    assert DungeonProcess.scorable?(dungeon_process)

    DungeonProcess.set_dungeon(dungeon_process, %{autogenerated: false, active: false})
    refute DungeonProcess.scorable?(dungeon_process)

    DungeonProcess.set_dungeon(dungeon_process, %{autogenerated: true, active: true})
    assert DungeonProcess.scorable?(dungeon_process)
  end

  test "set_author/2", %{dungeon_process: dungeon_process} do
    user = %User{id: 123}
    assert :ok = DungeonProcess.set_author(dungeon_process, user)
    assert %{author: ^user} = DungeonProcess.get_state(dungeon_process)
  end

  test "get_author/1", %{dungeon_process: dungeon_process} do
    user = %User{id: 123}
    DungeonProcess.set_author(dungeon_process, user)
    assert user == DungeonProcess.get_author(dungeon_process)
  end

  test "set_dungeon", %{dungeon_process: dungeon_process, dungeon_instance: dungeon_instance} do
    dungeon = Repo.preload(dungeon_instance, :dungeon).dungeon
    DungeonProcess.set_dungeon(dungeon_process, dungeon)
    assert %{dungeon: ^dungeon} = DungeonProcess.get_state(dungeon_process)
  end

  test "set_dungeon_instance", %{dungeon_process: dungeon_process, dungeon_instance: dungeon_instance} do
    DungeonProcess.set_dungeon_instance(dungeon_process, dungeon_instance)
    assert %{ dungeon_instance: ^dungeon_instance,
             instance_registry: instance_registry } = DungeonProcess.get_state(dungeon_process)
    dungeon_instance_id = dungeon_instance.id
    assert %{dungeon_instance_id: ^dungeon_instance_id} = :sys.get_state(instance_registry)
  end

  test "set_state_values", %{dungeon_process: dungeon_process} do
    assert :ok = DungeonProcess.set_state_values(dungeon_process, %{foo: :bar, baz: :qux})
    assert %{state_values: %{foo: :bar, baz: :qux}} = DungeonProcess.get_state(dungeon_process)
  end

  test "set_state_value", %{dungeon_process: dungeon_process} do
    assert :ok = DungeonProcess.set_state_value(dungeon_process, :foo, :bar)
    assert %{state_values: %{foo: :bar}} = DungeonProcess.get_state(dungeon_process)
  end

  test "get_dungeon", %{dungeon_process: dungeon_process, dungeon_instance: dungeon_instance} do
    dungeon = Repo.preload(dungeon_instance, :dungeon).dungeon
    DungeonProcess.set_dungeon(dungeon_process, dungeon)
    assert dungeon == DungeonProcess.get_dungeon(dungeon_process)
  end

  test "get_state_value", %{dungeon_process: dungeon_process} do
    DungeonProcess.set_state_value(dungeon_process, :foo, :bar)
    assert :bar = DungeonProcess.get_state_value(dungeon_process, :foo)
    refute DungeonProcess.get_state_value(dungeon_process, :bax)
  end

  test "get_instance_registry", %{dungeon_process: dungeon_process} do
    assert pid = DungeonProcess.get_instance_registry(dungeon_process)
    assert %{} = LevelRegistry.list(pid)
  end

  test "get_state", %{dungeon_process: dungeon_process} do
    assert %DungeonProcess{dungeon_instance: _,
                          state_values: _,
                          instance_registry: _,
                          entrances: []} = DungeonProcess.get_state(dungeon_process)
  end

  test "load_instance with an id", %{dungeon_process: dungeon_process, dungeon_instance: dungeon_instance} do
    [level_instance] = Repo.preload(dungeon_instance, :levels).levels
    level_instance_id = level_instance.id
    level_number = level_instance.number
    assert :ok = DungeonProcess.load_instance(dungeon_process, level_instance.id)
    assert %{^level_number => %{nil => {^level_instance_id, _pid}}} =
             DungeonProcess.get_instance_registry(dungeon_process)
             |> LevelRegistry.list()
    assert %DungeonProcess{entrances: []} = DungeonProcess.get_state(dungeon_process)
  end

  test "load_instance", %{dungeon_process: dungeon_process, dungeon_instance: dungeon_instance} do
    [level_instance] = Repo.preload(dungeon_instance, :levels).levels
    level_instance_id = level_instance.id
    level_number = level_instance.number
    assert :ok = DungeonProcess.load_instance(dungeon_process, level_instance)
    assert %{^level_number => %{nil => {^level_instance_id, _pid}}} =
             DungeonProcess.get_instance_registry(dungeon_process)
             |> LevelRegistry.list()
    assert %DungeonProcess{entrances: []} = DungeonProcess.get_state(dungeon_process)
  end

  test "load_instance that's an entrance", %{dungeon_process: dungeon_process, dungeon_instance: dungeon_instance} do
    [level_instance] = Repo.preload(dungeon_instance, :levels).levels
    level_instance_id = level_instance.id
    assert :ok = DungeonProcess.load_instance(dungeon_process, %{ level_instance | entrance: true })
    assert %DungeonProcess{entrances: [^level_instance_id]} = DungeonProcess.get_state(dungeon_process)
  end

  describe "check_for_players" do
    test "players, process sticks around", %{dungeon_process: dungeon_process, dungeon_instance: dungeon_instance} do
      level = Repo.preload(dungeon_instance, [levels: :tiles]).levels
              |> Enum.at(0)
      player_tile = level.tiles |> Enum.random() # it isn't really, but we'll pretend it is for sake of a test
      player_location = %Location{id: 555, tile_instance_id: player_tile.id}

      instance_registry = DungeonProcess.get_instance_registry(dungeon_process)
      LevelRegistry.set_dungeon_instance_id(instance_registry, level.dungeon_instance_id)
      assert level_registry = DungeonProcess.get_instance_registry(dungeon_process)
      assert {:ok, {_instance_id, instance_process}} = LevelRegistry.lookup_or_create(level_registry, level.number, player_location.id)

      LevelProcess.run_with(instance_process, fn(state) ->
        Levels.create_player_tile(state, player_tile, player_location)
      end)

      DungeonProcess.set_dungeon_instance(dungeon_process, dungeon_instance)
      DungeonProcess.set_dungeon(dungeon_process, Repo.preload(dungeon_instance, :dungeon).dungeon)
      assert Process.alive?(dungeon_process)
      DungeonProcess.start_scheduler(dungeon_process, 0) # check for players immediately
      :timer.sleep 50
      assert DungeonInstances.get_dungeon(dungeon_instance.id)
      assert Process.alive?(dungeon_process)
    end

    test "no players, process dies", %{dungeon_process: dungeon_process, dungeon_instance: dungeon_instance} do
      dungeon = Repo.preload(dungeon_instance, :dungeon).dungeon
      DungeonProcess.set_dungeon_instance(dungeon_process, dungeon_instance)
      DungeonProcess.set_dungeon(dungeon_process, dungeon)
      assert Process.alive?(dungeon_process)
      DungeonProcess.start_scheduler(dungeon_process, 0) # check for players immediately
      :timer.sleep 50
      assert Dungeons.get_dungeon(dungeon.id)
      refute DungeonInstances.get_dungeon(dungeon_instance.id)
      refute Process.alive?(dungeon_process)
    end

    test "no players, process dies, dungeon deleted if autogen", %{dungeon_process: dungeon_process, dungeon_instance: dungeon_instance} do
      dungeon = Repo.preload(dungeon_instance, :dungeon).dungeon
      DungeonProcess.set_dungeon_instance(dungeon_process, dungeon_instance)
      DungeonProcess.set_dungeon(dungeon_process, %{dungeon | autogenerated: true})
      assert Process.alive?(dungeon_process)
      DungeonProcess.start_scheduler(dungeon_process, 0) # check for players immediately
      :timer.sleep 50
      refute Dungeons.get_dungeon(dungeon.id)
      refute Process.alive?(dungeon_process)
    end
  end
end
