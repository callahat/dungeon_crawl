defmodule DungeonCrawl.MapSetProcessTest do
  use DungeonCrawl.DataCase

  alias DungeonCrawl.Account.User
  alias DungeonCrawl.DungeonInstances
  alias DungeonCrawl.DungeonProcesses.MapSetProcess
  alias DungeonCrawl.DungeonProcesses.InstanceRegistry
  alias DungeonCrawl.DungeonInstances.Tile

  # A lot of these tests are semi redundant, as the code that actually modifies the state lives
  # in the Instances module. Testing this also effectively hits the Instances code,
  # which also has its own set of similar tests.

  setup do
    map_set_process = start_supervised!(MapSetProcess)

    dungeon_instance = insert_stubbed_dungeon_instance(%{}, %{}, [[%Tile{character: "O", row: 1, col: 1, z_index: 0}]])

    %{map_set_process: map_set_process, dungeon_instance: dungeon_instance}
  end

  test "scorable?", %{map_set_process: map_set_process} do
    MapSetProcess.set_dungeon(map_set_process, %{autogenerated: false, active: true})
    MapSetProcess.set_state_value(map_set_process, :no_scoring, true)
    refute MapSetProcess.scorable?(map_set_process)

    MapSetProcess.set_state_value(map_set_process, :no_scoring, false)
    assert MapSetProcess.scorable?(map_set_process)

    MapSetProcess.set_state_value(map_set_process, :no_scoring, nil)
    assert MapSetProcess.scorable?(map_set_process)

    MapSetProcess.set_dungeon(map_set_process, %{autogenerated: false, active: false})
    refute MapSetProcess.scorable?(map_set_process)

    MapSetProcess.set_dungeon(map_set_process, %{autogenerated: true, active: true})
    refute MapSetProcess.scorable?(map_set_process)
  end

  test "set_author/2", %{map_set_process: map_set_process} do
    user = %User{id: 123}
    assert :ok = MapSetProcess.set_author(map_set_process, user)
    assert %{author: ^user} = MapSetProcess.get_state(map_set_process)
  end

  test "get_author/1", %{map_set_process: map_set_process} do
    user = %User{id: 123}
    MapSetProcess.set_author(map_set_process, user)
    assert user == MapSetProcess.get_author(map_set_process)
  end

  test "set_dungeon", %{map_set_process: map_set_process, dungeon_instance: dungeon_instance} do
    dungeon = Repo.preload(dungeon_instance, :dungeon).dungeon
    MapSetProcess.set_dungeon(map_set_process, dungeon)
    assert %{dungeon: ^dungeon} = MapSetProcess.get_state(map_set_process)
  end

  test "set_dungeon_instance", %{map_set_process: map_set_process, dungeon_instance: dungeon_instance} do
    MapSetProcess.set_dungeon_instance(map_set_process, dungeon_instance)
    assert %{ dungeon_instance: ^dungeon_instance } = MapSetProcess.get_state(map_set_process)
  end

  test "set_state_values", %{map_set_process: map_set_process} do
    assert :ok = MapSetProcess.set_state_values(map_set_process, %{foo: :bar, baz: :qux})
    assert %{state_values: %{foo: :bar, baz: :qux}} = MapSetProcess.get_state(map_set_process)
  end

  test "set_state_value", %{map_set_process: map_set_process} do
    assert :ok = MapSetProcess.set_state_value(map_set_process, :foo, :bar)
    assert %{state_values: %{foo: :bar}} = MapSetProcess.get_state(map_set_process)
  end

  test "get_dungeon", %{map_set_process: map_set_process, dungeon_instance: dungeon_instance} do
    dungeon = Repo.preload(dungeon_instance, :dungeon).dungeon
    MapSetProcess.set_dungeon(map_set_process, dungeon)
    assert dungeon == MapSetProcess.get_dungeon(map_set_process)
  end

  test "get_state_value", %{map_set_process: map_set_process} do
    MapSetProcess.set_state_value(map_set_process, :foo, :bar)
    assert :bar = MapSetProcess.get_state_value(map_set_process, :foo)
    refute MapSetProcess.get_state_value(map_set_process, :bax)
  end

  test "get_instance_registry", %{map_set_process: map_set_process} do
    assert pid = MapSetProcess.get_instance_registry(map_set_process)
    assert %{} = InstanceRegistry.list(pid)
  end

  test "get_state", %{map_set_process: map_set_process} do
    assert %MapSetProcess{dungeon_instance: _,
                          state_values: _,
                          instance_registry: _,
                          entrances: []} = MapSetProcess.get_state(map_set_process)
  end

  test "load_instance with an id", %{map_set_process: map_set_process, dungeon_instance: dungeon_instance} do
    [level_instance] = Repo.preload(dungeon_instance, :levels).levels
    level_instance_id = level_instance.id
    assert :ok = MapSetProcess.load_instance(map_set_process, level_instance.id)
    assert %{^level_instance_id => _} = MapSetProcess.get_instance_registry(map_set_process)
                                        |> InstanceRegistry.list()
    assert %MapSetProcess{entrances: []} = MapSetProcess.get_state(map_set_process)
  end

  test "load_instance", %{map_set_process: map_set_process, dungeon_instance: dungeon_instance} do
    [level_instance] = Repo.preload(dungeon_instance, :levels).levels
    level_instance_id = level_instance.id
    assert :ok = MapSetProcess.load_instance(map_set_process, level_instance)
    assert %{^level_instance_id => _} = MapSetProcess.get_instance_registry(map_set_process)
                                        |> InstanceRegistry.list()
    assert %MapSetProcess{entrances: []} = MapSetProcess.get_state(map_set_process)
  end

  test "load_instance that's an entrance", %{map_set_process: map_set_process, dungeon_instance: dungeon_instance} do
    [level_instance] = Repo.preload(dungeon_instance, :levels).levels
    level_instance_id = level_instance.id
    assert :ok = MapSetProcess.load_instance(map_set_process, %{ level_instance | entrance: true })
    assert %MapSetProcess{entrances: [^level_instance_id]} = MapSetProcess.get_state(map_set_process)
  end

  describe "check_for_players" do
    test "no players, process dies", %{map_set_process: map_set_process, dungeon_instance: dungeon_instance} do
      MapSetProcess.set_dungeon_instance(map_set_process, dungeon_instance)
      assert Process.alive?(map_set_process)
      MapSetProcess.start_scheduler(map_set_process, 0) # check for players immediately
      :timer.sleep 50
      refute DungeonInstances.get_dungeon(dungeon_instance.id)
      refute Process.alive?(map_set_process)
    end
  end
end
