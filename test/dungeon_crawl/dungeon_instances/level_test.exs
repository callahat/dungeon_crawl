defmodule DungeonCrawl.DungeonInstances.LevelTest do
  use DungeonCrawl.DataCase

  alias DungeonCrawl.Repo
  alias DungeonCrawl.DungeonInstances.Level
  alias DungeonCrawl.Player.Location

  test "on_delete deletes all associated player_locations" do
    level_instance = insert_autogenerated_level_instance()
    player_loc = insert_player_location(%{level_instance_id: level_instance.id})
    assert Repo.preload(level_instance, :locations).locations != []
    assert Repo.delete(level_instance)
    refute Repo.get_by(Location, %{user_id_hash: player_loc.user_id_hash})
    assert Repo.preload(level_instance, :locations).locations == []
  end

  test "level_instance number must be unique for dungeon and owner" do
    level_instance = insert_autogenerated_level_instance()
    changeset = Level.changeset(
                  %Level{player_location_id: nil},
                  Map.take(level_instance, [:number, :name, :level_id, :dungeon_instance_id, :height, :width])
                )

    assert {:error, %{errors: [number: {"Level Number already exists", _}]}} = Repo.insert(changeset)

    # level instance that is owned by a player
    other_player = insert_player_location(%{level_instance_id: level_instance.id})
    changeset = Level.changeset(
      %Level{},
      Map.take(level_instance, [:number, :name, :level_id, :dungeon_instance_id, :height, :width])
      |> Map.merge(%{player_location_id: other_player.id})
    )

    assert {:ok, _level} = Repo.insert(changeset)

    assert {:error, %{errors: [number: {"Level Number already exists", _}]}} = Repo.insert(changeset)
  end

  test "passage_exits" do
    level_instance_no_exits = insert_autogenerated_level_instance()
    level_instance = insert_autogenerated_level_instance(%{passage_exits: [{3, "seeded"}]})

    # retrieval
    assert [{3, "seeded"}] == level_instance.passage_exits
    assert [] == level_instance_no_exits.passage_exits

    # invalid passage exits
    assert %{errors: [{:passage_exits, {"is invalid", _}}]} =
        Level.changeset(level_instance, %{passage_exits: [{"123", "junk"}]})
    assert %{errors: [{:passage_exits, {"is invalid", _}}]} =
             Level.changeset(level_instance, %{passage_exits: "just wrong"})

    # valid passage exits
    assert [] == Level.changeset(level_instance, %{passage_exits: [{123, "junk"}]}).errors
    assert [] == Level.changeset(level_instance, %{passage_exits: [{123, "junk"},{1,"grey"}]}).errors
  end
end
