defmodule DungeonCrawl.DungeonTest do
  use DungeonCrawl.DataCase

  alias DungeonCrawl.Dungeon

  describe "dungeons" do
    alias DungeonCrawl.Dungeon.Map

    @valid_attrs %{name: "some content"}
    @update_attrs %{name: "new name"}
    @invalid_attrs %{height: 1}

    def map_fixture(attrs \\ %{}) do
      {:ok, map} =
        attrs
        |> Enum.into(@valid_attrs)
        |> Dungeon.create_map()

      map
    end

    test "list_dungeons/0 returns all dungeons" do
      map = map_fixture()
      assert Dungeon.list_dungeons() == [map]
    end

    test "get_map!/1 returns the map with given id" do
      map = map_fixture()
      assert Dungeon.get_map!(map.id) == map
    end

    test "create_map/1 with valid data creates a map" do
      assert {:ok, %Map{} = _map} = Dungeon.create_map(@valid_attrs)
    end

    test "create_map/1 with invalid data returns error changeset" do
      assert {:error, %Ecto.Changeset{}} = Dungeon.create_map(@invalid_attrs)
    end

    test "generate_map/2 returns an autogenerated map" do
      assert {:ok, %{dungeon: %Map{} = _map}} = Dungeon.generate_map(DungeonCrawl.DungeonGenerator.TestRooms, @valid_attrs)
    end

    test "generate_map/2 with invalid data returns error changeset" do
      assert {:error, :dungeon, %Ecto.Changeset{}, _others} = Dungeon.generate_map(DungeonCrawl.DungeonGenerator.TestRooms, @invalid_attrs)
    end

    test "update_map/2 with valid data updates the map" do
      map = map_fixture()
      assert {:ok, map} = Dungeon.update_map(map, @update_attrs)
      assert %Map{} = map
    end

    test "update_map/2 with invalid data returns error changeset" do
      map = map_fixture()
      assert {:error, %Ecto.Changeset{}} = Dungeon.update_map(map, @invalid_attrs)
      assert map == Dungeon.get_map!(map.id)
    end

    test "delete_map/1 deletes the map" do
      map = map_fixture()
      assert {:ok, %Map{}} = Dungeon.delete_map(map)
      assert_raise Ecto.NoResultsError, fn -> Dungeon.get_map!(map.id) end
    end

    test "change_map/1 returns a map changeset" do
      map = map_fixture()
      assert %Ecto.Changeset{} = Dungeon.change_map(map)
    end
  end

  describe "dungeon_map_tiles" do
    alias DungeonCrawl.Dungeon.MapTile

    @valid_attrs %{tile: "!", row: 15, col: 42}
    @update_attrs %{tile: "."}
    @invalid_attrs %{tile: "bad"}

    def map_tile_fixture(attrs \\ %{}) do
      {:ok, map} = Dungeon.create_map(%{name: "test"})
      {:ok, map_tile} =
        Elixir.Map.merge(%MapTile{}, @valid_attrs)
        |> Elixir.Map.merge(%{dungeon_id: map.id})
        |> Elixir.Map.merge(attrs)
        |> Repo.insert()

      map_tile
    end

    test "list_dungeon_map_tiles/0 returns all dungeon_map_tiles" do
      map_tile = map_tile_fixture()
      assert Dungeon.list_dungeon_map_tiles() == [map_tile]
    end

    test "get_map_tile!/1 returns the map_tile with given id" do
      map_tile = map_tile_fixture()
      assert Dungeon.get_map_tile!(map_tile.id) == map_tile
    end

    test "create_map_tile/1 with valid data creates a map_tile" do
      assert {:ok, %MapTile{} = _map_tile} = Dungeon.create_map_tile(@valid_attrs)
    end

    test "create_map_tile/1 with invalid data returns error changeset" do
      assert {:error, %Ecto.Changeset{}} = Dungeon.create_map_tile(@invalid_attrs)
    end

    test "update_map_tile/2 with valid data updates the map_tile" do
      map_tile = map_tile_fixture()
      assert {:ok, map_tile} = Dungeon.update_map_tile(map_tile, @update_attrs.tile)
      assert %MapTile{} = map_tile
    end

    test "update_map_tile/2 with invalid data returns error changeset" do
      map_tile = map_tile_fixture()
      assert {:error, %Ecto.Changeset{}} = Dungeon.update_map_tile(map_tile, @invalid_attrs)
      assert map_tile == Dungeon.get_map_tile!(map_tile.id)
    end

    test "change_map_tile/1 returns a map_tile changeset" do
      map_tile = map_tile_fixture()
      assert %Ecto.Changeset{} = Dungeon.change_map_tile(map_tile)
    end

    test "get_map_tile/1 returns a map_tile" do
      map_tile = map_tile_fixture()
      assert Dungeon.get_map_tile(%{dungeon_id: map_tile.dungeon_id, row: map_tile.row, col: map_tile.col}) == map_tile
      refute Dungeon.get_map_tile(%{dungeon_id: map_tile.dungeon_id+1, row: map_tile.row, col: map_tile.col})
    end

    test "get_map_tile/3 returns a map_tile" do
      map_tile = map_tile_fixture()
      assert Dungeon.get_map_tile(map_tile.dungeon_id, map_tile.row, map_tile.col) == map_tile
      refute Dungeon.get_map_tile(map_tile.dungeon_id + 1, map_tile.row, map_tile.col)
    end
  end
end
