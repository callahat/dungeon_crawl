defmodule DungeonCrawl.DungeonsTest do
  use DungeonCrawl.DataCase

  alias DungeonCrawl.Dungeons
  alias DungeonCrawl.MapGenerators.TestRooms

  describe "map_sets" do
    alias DungeonCrawl.Dungeons.Map
    alias DungeonCrawl.Dungeons.MapSet

    @valid_attrs %{name: "some content"}
    @valid_map_attrs %{height: 20, width: 20}
    @update_attrs %{name: "new name"}
    @invalid_attrs %{name: ""}

    def map_set_fixture(attrs \\ %{}) do
      {:ok, map_set} =
        attrs
        |> Enum.into(@valid_attrs)
        |> Dungeons.create_map_set()

      map_set
    end

    test "list_map_sets/0 returns all map_sets" do
      map_set = map_set_fixture()
      assert Dungeons.list_map_sets() == [map_set]
    end

    test "list_map_sets/1 returns all map_sets owned by the user" do
      map_set_fixture()
      user = insert_user()
      map_set = map_set_fixture(%{user_id: user.id})
      assert Dungeons.list_map_sets(user) == [map_set]
    end

    test "list_map_sets/1 returns all soft deleted map_sets" do
      map_set_deleted = map_set_fixture()
      map_set_fixture()
      Dungeons.delete_map_set(map_set_deleted)
      assert Dungeons.list_map_sets(:soft_deleted) == [Dungeons.get_map_set(map_set_deleted.id)]
    end

    test "list_map_sets_with_player_count/0 returns all dungeons preloaded with the players in the map instances" do
      map_set_fixture = map_set_fixture()
      map = insert_autogenerated_dungeon_instance(%{map_set_id: map_set_fixture.id})

      assert [%{map_set_id: map_set_id, map_set: map_set}] = Dungeons.list_map_sets_with_player_count()

      assert map_set_id == map_set_fixture.id
      assert Enum.count(map_set.locations) == 0

      _p1 = insert_player_location(%{map_instance_id: map.id})
      _p2 = insert_player_location(%{map_instance_id: map.id, user_id_hash: "different"})

      assert [%{map_set_id: map_set_id, map_set: map_set}] = Dungeons.list_map_sets_with_player_count()

      assert map_set_id == map_set_fixture.id
      assert Enum.count(map_set.locations) == 2
    end

    test "list_active_map_sets_with_player_count/0 returns all active dungeons preloaded with the players in the map instances" do
      insert_stubbed_map_set_instance(%{active: false})
      insert_stubbed_map_set_instance(%{active: true, deleted_at: NaiveDateTime.utc_now |> NaiveDateTime.truncate(:second)})

      msi = insert_stubbed_map_set_instance(%{active: true})
      map = Repo.preload(msi, :maps).maps |> Enum.at(0)

      insert_player_location(%{map_instance_id: map.id})

      assert [%{map_set_id: map_set_id, map_set: map_set}] = Dungeons.list_active_map_sets_with_player_count()

      assert map_set_id == msi.map_set_id
      assert Enum.count(map_set.locations) == 1
    end

    test "instance_count/1 returns the number of instances existing for the dungeon" do
      assert Dungeons.instance_count(1) == 0

      msi = insert_autogenerated_map_set_instance(%{active: false})

      assert Dungeons.instance_count(msi.map_set_id) == 1
      assert Dungeons.instance_count(%MapSet{id: msi.map_set_id}) == 1
    end

    test "get_map_set!/1 returns the map with given id" do
      map_set = map_set_fixture()
      assert map_set == Dungeons.get_map_set!(map_set.id)
      assert map_set == Dungeons.get_map_set(map_set.id)
    end

    test "get_map_sets/1 returns the different versions of the map set's line identifier" do
      map_set = map_set_fixture()
      map_set2 = map_set_fixture(%{version: 2, line_identifier: map_set.line_identifier})
      map_set_fixture(%{line_identifier: map_set.id + 1})
      assert [map_set2, map_set] == Dungeons.get_map_sets(map_set.line_identifier)
    end

    test "get_title_map/1" do
      map_set = map_set_fixture()
      refute Dungeons.get_title_map(map_set)
      map1 = insert_stubbed_dungeon(%{map_set_id: map_set.id, number: 1})
      map2 = insert_stubbed_dungeon(%{map_set_id: map_set.id, number: 2})
      assert Dungeons.get_title_map(map_set).id == map1.id
      assert Dungeons.get_title_map(Elixir.Map.put(map_set, :title_number, map2.number)).id == map2.id
      refute Dungeons.get_title_map(Elixir.Map.put(map_set, :title_number, 0))
    end

    test "next_version_exists?/1 is true if the map set has a next version" do
      map_set = insert_stubbed_map_set()
      insert_stubbed_map_set(%{previous_version_id: map_set.id})
      assert Dungeons.next_version_exists?(map_set)
    end

    test "next_version_exists?/1 is false if the map does not have a next version" do
      map_set = insert_stubbed_map_set()
      refute Dungeons.next_version_exists?(map_set)
    end

    test "copy_map_set_fields/1" do
      map_set = insert_stubbed_map_set()
      assert %{autogenerated: false,
               default_map_height: nil,
               default_map_width: nil,
               name: "Autogenerated",
               state: nil,
               user_id: nil,
               line_identifier: map_set.line_identifier,
               description: nil,
               title_number: nil} == Dungeons.copy_map_set_fields(map_set)
    end

    test "create_map_set/1 with valid data creates a map" do
      assert {:ok, %MapSet{} = map_set} = Dungeons.create_map_set(@valid_attrs)
      assert map_set.id == map_set.line_identifier
    end

    test "create_map_set/1 with invalid data returns error changeset" do
      assert {:error, %Ecto.Changeset{}} = Dungeons.create_map_set(@invalid_attrs)
    end

    test "create_new_map_set_version/1 does not create a new version of an inactive map" do
      map_set = insert_stubbed_map_set(%{active: false})
      assert {:error, "Inactive map set"} = Dungeons.create_new_map_set_version(map_set)
    end

    test "create_new_map_set_version/1 does not create a new version if any maps have legacy dimensions which are now invalid" do
      map_set = insert_stubbed_map_set(%{active: true}, %{height: 40, width: 40})
      DungeonCrawl.Admin.update_setting(%{autogen_height: 20, autogen_width: 20, max_width: 20, max_height: 20})
      assert {:error, :new_maps, _, _} = Dungeons.create_new_map_set_version(map_set)
    end

    test "create_new_map_set_version/1 creates a new version" do
      map_set = insert_autogenerated_map_set(%{active: true})
      map = Repo.preload(map_set, :dungeons).dungeons |> Enum.at(0)
      Repo.insert_all(Dungeons.SpawnLocation, [%{dungeon_id: map.id, row: 1, col: 1}, %{dungeon_id: map.id, row: 1, col: 2}])
      assert {:ok, new_map_set} = Dungeons.create_new_map_set_version(map_set)
      assert new_map_set.version == map_set.version + 1
      assert new_map_set.line_identifier == map_set.line_identifier

      assert %MapSet{} = new_map_set
      old_tiles = Repo.preload(map, :dungeon_map_tiles).dungeon_map_tiles
                  |> Enum.map(fn(t) -> Elixir.Map.take(t, [:row, :col, :z_index, :tile_template_id, :character, :color, :background_color, :state, :script]) end)
      old_spawn_locations = Repo.preload(map, :spawn_locations).spawn_locations
                            |> Enum.map(fn(sl) -> {sl.row, sl.col} end)
      new_map = Repo.preload(new_map_set, :dungeons).dungeons |> Enum.at(0)
      new_tiles = Repo.preload(new_map, :dungeon_map_tiles).dungeon_map_tiles
                  |> Enum.map(fn(t) -> Elixir.Map.take(t, [:row, :col, :z_index, :tile_template_id, :character, :color, :background_color, :state, :script]) end)
      new_spawn_locations = Repo.preload(new_map, :spawn_locations).spawn_locations
                            |> Enum.map(fn(sl) -> {sl.row, sl.col} end)
      assert Elixir.Map.delete(Elixir.Map.delete(map, :id), :map_set_id) ==
             Elixir.Map.delete(Elixir.Map.delete(new_map, :id), :map_set_id)
      assert old_tiles == new_tiles
      assert old_spawn_locations == new_spawn_locations
    end

    test "create_new_map_version/1 does not create a new version if the next one exists" do
      map_set = insert_stubbed_map_set(%{active: true})
      insert_stubbed_map_set(%{previous_version_id: map_set.id})
      assert {:error, "New version already exists"} = Dungeons.create_new_map_set_version(map_set)
    end

    test "generate_map_set/4 returns an autogenerated map" do
      assert {:ok, %MapSet{} = map_set} = Dungeons.generate_map_set(TestRooms, @valid_attrs, @valid_map_attrs)
      assert map_set.autogenerated
      assert Enum.at(Repo.preload(map_set, :dungeons).dungeons,0).entrance
    end

    test "generate_map_set/4 with invalid data returns error changeset" do
      assert {:error, %Ecto.Changeset{}} = Dungeons.generate_map_set(TestRooms, @invalid_attrs)
      assert {:error, :dungeon, %Ecto.Changeset{}, _others} = Dungeons.generate_map_set(TestRooms, @valid_attrs)
    end

    test "update_map_set/2 with valid data updates the map_set" do
      map_set = map_set_fixture()
      assert {:ok, map_set} = Dungeons.update_map_set(map_set, @update_attrs)
      assert %MapSet{} = map_set
    end

    test "update_map_set/2 with invalid data returns error changeset" do
      map_set = map_set_fixture()
      assert {:error, %Ecto.Changeset{}} = Dungeons.update_map_set(map_set, @invalid_attrs)
      assert map_set == Dungeons.get_map_set!(map_set.id)
    end

    test "activate_map_set/1 with map set activtes map set" do
      map_set = map_set_fixture()
      refute map_set.active
      assert {:ok, activated_map_set} = Dungeons.activate_map_set(map_set)
      assert activated_map_set == Dungeons.get_map_set(map_set.id)
      assert activated_map_set.active
    end

    test "activate_map_set/1 soft deletes the previous version" do
      map_set = map_set_fixture()
      new_map_set = map_set_fixture(%{previous_version_id: map_set.id})
      assert {:ok, activated_map_set} = Dungeons.activate_map_set(new_map_set)
      assert Dungeons.get_map_set(map_set.id).deleted_at
      assert Dungeons.get_map_set(new_map_set.id).active
      assert new_map_set.id == activated_map_set.id
    end

    test "activate_map_set/1 with map set that has inactive tiles returns error message" do
      tile_a = insert_tile_template(%{name: "ACT", active: true})
      tile_b = insert_tile_template(%{name: "INT", active: false})
      map_set = insert_stubbed_map_set(%{}, %{},
                  [[Elixir.Map.merge(%{tile_template_id: tile_a.id, row: 1, col: 1, z_index: 0},
                                     Elixir.Map.take(tile_a, [:character, :color, :background_color, :state, :script])),
                    Elixir.Map.merge(%{tile_template_id: tile_a.id, row: 1, col: 2, z_index: 0},
                                     Elixir.Map.take(tile_a, [:character, :color, :background_color, :state, :script])),
                    Elixir.Map.merge(%{tile_template_id: tile_b.id, row: 1, col: 3, z_index: 0},
                                     Elixir.Map.take(tile_b, [:character, :color, :background_color, :state, :script]))]])

      assert {:error, error_msg} = Dungeons.activate_map_set(map_set)
      assert error_msg == "Inactive tiles: INT (id: #{tile_b.id}) 1 times"
    end

    test "delete_map_set/1 soft deletes the map set" do
      map_set = map_set_fixture()
      assert {:ok, map_set} = Dungeons.delete_map_set(map_set)
      assert %MapSet{} = map_set
      assert map_set.deleted_at
    end

    test "hard_delete_map_set!/1 deletes the map set" do
      map_set = insert_stubbed_map_set(%{active: true})
      map = Repo.preload(map_set, :dungeons).dungeons |> Enum.at(0)
      Repo.insert_all(Dungeons.SpawnLocation, [%{dungeon_id: map.id, row: 1, col: 1}, %{dungeon_id: map.id, row: 1, col: 2}])
      assert map_set = Dungeons.hard_delete_map_set!(map_set)
      assert %MapSet{} = map_set
      refute DungeonCrawl.Repo.get Dungeons.MapSet, map_set.id
    end

    test "change_map_set/1 returns a map set changeset" do
      map_set = map_set_fixture()
      assert %Ecto.Changeset{} = Dungeons.change_map_set(map_set)
    end
  end

  describe "dungeons" do
    alias DungeonCrawl.Dungeons.Map
    alias DungeonCrawl.Dungeons.MapSet

    @valid_attrs %{name: "some content", height: 40, width: 80}
    @update_attrs %{name: "new name"}
    @invalid_attrs %{height: 1}

    def map_fixture(attrs \\ %{})
    def map_fixture(%{map_set_id: map_set_id} = attrs) do
      {:ok, map} =
        attrs
        |> Enum.into(@valid_attrs)
        |> Elixir.Map.put(:map_set_id, map_set_id)
        |> Dungeons.create_map()

      map
    end
    def map_fixture(attrs) do
      {:ok, map_set} = Dungeons.create_map_set(%{name: "map set"})
      map_fixture(Elixir.Map.put(attrs, :map_set_id, map_set.id))
    end

    test "list_dungeons/0 returns all dungeons for a map set" do
      map = map_fixture()
      assert Dungeons.list_dungeons(%MapSet{id: map.map_set_id}) == [map]
    end

    test "list_dungeons_with_player_count/0 returns all dungeons preloaded with the players in the map instances" do
      map_i = insert_autogenerated_dungeon_instance()
      insert_autogenerated_dungeon_instance(%{map_set_id: Repo.preload(map_i, :map_set).map_set.map_set_id, number: 2})
      msi = Repo.preload(map_i, :map_set).map_set

      assert [%{dungeon_id: _dungeon_id1, dungeon: dungeon1}, %{dungeon_id: _dungeon_id2, dungeon: _dungeon2}] =
               Dungeons.list_dungeons_with_player_count(%MapSet{id: msi.map_set_id})

      assert dungeon1.id == map_i.map_id
      assert Enum.count(Repo.preload(map_i, [dungeon: :locations]).dungeon.locations) == 0

      insert_player_location(%{map_instance_id: map_i.id})
      insert_player_location(%{map_instance_id: map_i.id, user_id_hash: "different"})

      assert [%{dungeon_id: _dungeon_id1, dungeon: _dungeon1}, %{dungeon_id: _dungeon_id2, dungeon: _dungeon2}] =
               Dungeons.list_dungeons_with_player_count(%MapSet{id: msi.map_set_id})
      assert Enum.count(Repo.preload(map_i, [dungeon: :locations]).dungeon.locations) == 2
    end

    test "next_level_number/1" do
      map = map_fixture()
      map_set_1 = Repo.preload(map, :map_set).map_set
      map_set_2 = insert_map_set()

      assert Dungeons.next_level_number(map_set_1) == 2
      assert Dungeons.next_level_number(map_set_2) == 1 # has no maps
    end

    test "get_map!/1 returns the map with given id" do
      map = map_fixture()
      assert Dungeons.get_map!(map.id) == map
    end

    test "get_map/2 returns the map in the map set instance for that number" do
      map = map_fixture()
      assert Dungeons.get_map(map.map_set_id, map.number) == map
      refute Dungeons.get_map(map.map_set_id, 123)
    end

    test "get_bounding_z_indexes!/1 returns the map's lowest and highest z index for given id" do
      tile_a = insert_tile_template()
      map = insert_stubbed_dungeon(%{},
              [Elixir.Map.merge(%{tile_template_id: tile_a.id, row: 1, col: 1, z_index: 0},
                                Elixir.Map.take(tile_a, [:character, :color, :background_color, :state, :script])),
               Elixir.Map.merge(%{tile_template_id: tile_a.id, row: 1, col: 1, z_index: 2},
                                Elixir.Map.take(tile_a, [:character, :color, :background_color, :state, :script]))])

      assert Dungeons.get_bounding_z_indexes(map.id) == {0,2}
      assert Dungeons.get_bounding_z_indexes(map) == {0,2}
    end

    test "list_historic_tile_templates/1 when no historic tiles returns an empty array" do
      tile_a = insert_tile_template()
      tile_b = insert_tile_template()
      map = insert_stubbed_dungeon(%{},
              [Elixir.Map.merge(%{tile_template_id: tile_a.id, row: 1, col: 1, z_index: 0},
                                Elixir.Map.take(tile_a, [:character, :color, :background_color, :state, :script])),
               Elixir.Map.merge(%{tile_template_id: tile_a.id, row: 1, col: 2, z_index: 0},
                                Elixir.Map.take(tile_a, [:character, :color, :background_color, :state, :script])),
               Elixir.Map.merge(%{tile_template_id: tile_b.id, row: 1, col: 3, z_index: 0},
                                Elixir.Map.take(tile_b, [:character, :color, :background_color, :state, :script]))])
      assert Dungeons.list_historic_tile_templates(map) == []
    end

    test "list_historic_tile_templates/1 returns array of distinct historic tile templates" do
      tile_a = insert_tile_template()
      tile_b = insert_tile_template()
      map = insert_stubbed_dungeon(%{},
              [Elixir.Map.merge(%{tile_template_id: tile_a.id, row: 1, col: 1, z_index: 0},
                                Elixir.Map.take(tile_a, [:character, :color, :background_color, :state, :script])),
               Elixir.Map.merge(%{tile_template_id: tile_a.id, row: 1, col: 2, z_index: 0},
                                Elixir.Map.take(tile_a, [:character, :color, :background_color, :state, :script])),
               Elixir.Map.merge(%{tile_template_id: tile_b.id, row: 1, col: 3, z_index: 0},
                                Elixir.Map.take(tile_b, [:character, :color, :background_color, :state, :script]))])
      {:ok, tile_a} = DungeonCrawl.TileTemplates.delete_tile_template(tile_a)
      assert Dungeons.list_historic_tile_templates(map) == [tile_a]
    end

    test "copy_map_fields/1" do
      map = insert_stubbed_dungeon()
      assert %{entrance: nil,
               height: 20,
               name: "Stubbed",
               number: 1,
               number_east: nil,
               number_north: nil,
               number_south: nil,
               number_west: nil,
               state: nil,
               width: 20} == Dungeons.copy_map_fields(map)
    end

    test "create_map/1 with valid data creates a map" do
      assert {:ok, %Map{} = _map} = Dungeons.create_map(Elixir.Map.put(@valid_attrs, :map_set_id, insert_map_set().id))
    end

    test "create_map/1 with invalid data returns error changeset" do
      assert {:error, %Ecto.Changeset{}} = Dungeons.create_map(@invalid_attrs)
    end

    test "generate_map/2 returns an autogenerated map" do
      assert {:ok, %{dungeon: %Map{} = _map}} = Dungeons.generate_map(TestRooms, Elixir.Map.put(@valid_attrs, :map_set_id, insert_map_set().id))
    end

    test "generate_map/2 with invalid data returns error changeset" do
      assert {:error, :dungeon, %Ecto.Changeset{}, _others} = Dungeons.generate_map(TestRooms, @invalid_attrs)
    end

    test "update_map/2 with valid data updates the map" do
      map = map_fixture()
      assert {:ok, map} = Dungeons.update_map(map, @update_attrs)
      assert %Map{} = map
    end

    test "update_map/2 with bigger dimensions creates new emtpy map tiles" do
      map = insert_autogenerated_dungeon()
      refute Dungeons.get_map_tile(map.id, map.width, map.height)
      assert {:ok, _updated_map} = Dungeons.update_map(map, %{width: map.width + 1, height: map.height + 1})
      assert Dungeons.get_map_tile(map.id, map.width, map.height).tile_template_id
    end

    test "update_map/2 with smaller dimensions deletes map tiles" do
      map = insert_autogenerated_dungeon()
      Repo.insert_all(Dungeons.SpawnLocation, [%{dungeon_id: map.id, row: 1, col: map.width-1},
                                              %{dungeon_id: map.id, row: map.height-1, col: 2},
                                              %{dungeon_id: map.id, row: 1, col: 1}])
      refute Dungeons.get_map_tile(map.id, map.width, map.height)
      assert Dungeons.get_map_tile(map.id, map.width-1, map.height-1)
      assert {:ok, _updated_map} = Dungeons.update_map(map, %{width: map.width - 1, height: map.height - 1})
      refute Dungeons.get_map_tile(map.id, map.width-1, map.height-1)
      assert [%{row: 1, col: 1}] = Repo.preload(map, :spawn_locations).spawn_locations
    end


    test "update_map/2 with invalid data returns error changeset" do
      map = map_fixture()
      assert {:error, %Ecto.Changeset{}} = Dungeons.update_map(map, @invalid_attrs)
      assert map == Dungeons.get_map!(map.id)
    end

    test "delete_map/1 deletes the map" do
      map = map_fixture()
      Repo.insert_all(Dungeons.SpawnLocation, [%{dungeon_id: map.id, row: 1, col: 1}, %{dungeon_id: map.id, row: 1, col: 2}])
      assert {:ok, map} = Dungeons.delete_map(map)
      assert %Map{} = map
      refute DungeonCrawl.Repo.get Dungeons.Map, map.id
    end

    test "link_unlinked_maps/1 links adjacent maps if they are not already linked" do
      map_1 = map_fixture(%{number: 1, number_north: 2, number_west: 3})
      map_2 = map_fixture(%{number: 2, map_set_id: map_1.map_set_id, number_south: 3})
      map_3 = map_fixture(%{number: 3, map_set_id: map_1.map_set_id})

      assert Dungeons.link_unlinked_maps(map_1)

      assert %{number_north:   2, number_south: nil, number_east: nil, number_west:   3} = Dungeons.get_map(map_1.id)
      assert %{number_north: nil, number_south:   3, number_east: nil, number_west: nil} = Dungeons.get_map(map_2.id)
      assert %{number_north: nil, number_south: nil, number_east:   1, number_west: nil} = Dungeons.get_map(map_3.id)
    end

    test "delete_map!/1 deletes the map" do
      map = map_fixture()
      Repo.insert_all(Dungeons.SpawnLocation, [%{dungeon_id: map.id, row: 1, col: 1}, %{dungeon_id: map.id, row: 1, col: 2}])
      assert map = Dungeons.delete_map!(map)
      assert %Map{} = map
      refute DungeonCrawl.Repo.get Dungeons.Map, map.id
    end

    test "tile_template_reference_count/1 returns a count of the template being used" do
      tile_a = insert_tile_template()
      tile_b = insert_tile_template()
      insert_stubbed_dungeon(%{},
        [Elixir.Map.merge(%{tile_template_id: tile_a.id, row: 1, col: 1, z_index: 0},
                          Elixir.Map.take(tile_a, [:character, :color, :background_color, :state, :script])),
         Elixir.Map.merge(%{tile_template_id: tile_a.id, row: 1, col: 2, z_index: 0},
                          Elixir.Map.take(tile_a, [:character, :color, :background_color, :state, :script])),
         Elixir.Map.merge(%{tile_template_id: tile_b.id, row: 1, col: 3, z_index: 0},
                          Elixir.Map.take(tile_b, [:character, :color, :background_color, :state, :script]))])

      assert 2 == Dungeons.tile_template_reference_count(tile_a.id)
      assert 1 == Dungeons.tile_template_reference_count(tile_b)
    end

    test "change_map/1 returns a map changeset" do
      map = map_fixture()
      assert %Ecto.Changeset{} = Dungeons.change_map(map)
    end

    test "adjacent_map_names/1" do
      map_1 = map_fixture(%{number: 1, number_north: 2, number_west: 3})
      _map_2 = map_fixture(%{number: 2, map_set_id: map_1.map_set_id, number_south: 3})
      _map_3 = map_fixture(%{number: 3, map_set_id: map_1.map_set_id, name: "Number Three"})

      assert %{ north: "2 - some content",
                south: nil,
                east: nil,
                west: "3 - Number Three"} == Dungeons.adjacent_map_names(map_1)
    end

    test "adjacent_map_edge_tiles/1" do
      map_1 = map_fixture(%{number: 1, number_east: 2, number_south: 2, number_west: 2})
      _map_2 = insert_autogenerated_dungeon(%{number: 2, map_set_id: map_1.map_set_id})

      assert %{north: nil,
               south: southern_edge_tiles,
               west: western_edge_tiles,
               east: eastern_edge_tiles} = Dungeons.adjacent_map_edge_tiles(map_1)
      assert length(southern_edge_tiles) == 21
      assert length(western_edge_tiles) == 21
      assert length(eastern_edge_tiles) == 21

      [ actual_list_south, actual_list_west, actual_list_east] = \
        [southern_edge_tiles, western_edge_tiles, eastern_edge_tiles]
        |> Enum.map(fn tiles -> tiles
                                |> Enum.map(fn tile -> Elixir.Map.take(tile, [:row, :col, :character]) end)
                                |> Enum.sort(fn a,b -> {a.row, a.col} < {b.row, b.col} end)
                    end)

      # this is what the test room generator generates, hardcoded basically
      expected_list_south = Enum.map(0..16, fn i -> %{row: 0, col: i, character: "#"} end) ++
                            Enum.map(17..20, fn i -> %{row: 0, col: i, character: " "} end)
      expected_list_west = Enum.map(0..20, fn i -> %{row: i, col: 20, character: " "} end)
      expected_list_east = Enum.map(0..4, fn i -> %{row: i, col: 0, character: "#"} end) ++
                           Enum.map(5..20, fn i -> %{row: i, col: 0, character: " "} end)
      assert expected_list_south == actual_list_south
      assert expected_list_west == actual_list_west
      assert expected_list_east == actual_list_east
    end

    test "adjacent_map_edge_tile/2" do
      map_1 = map_fixture(%{number: 1, number_north: 2})
      _map_2 = insert_autogenerated_dungeon(%{number: 2, map_set_id: map_1.map_set_id})

      assert %{north: northern_edge_tiles} = Dungeons.adjacent_map_edge_tile(map_1, "north")

      actual_list_north = Enum.map(northern_edge_tiles, fn tile -> Elixir.Map.take(tile, [:row, :col, :character]) end)
                          |> Enum.sort(fn a,b -> {a.row, a.col} < {b.row, b.col} end)

      expected_list_north = Enum.map(0..20, fn i -> %{row: 20, col: i, character: " "} end)
      assert expected_list_north == actual_list_north
    end

    test "map_edge_tiles/3" do
      map_1 = map_fixture(%{number: 1, number_north: 2})
      map_2 = insert_autogenerated_dungeon(%{number: 2, map_set_id: map_1.map_set_id})

      assert northern_edge_tiles = Dungeons.map_edge_tiles(map_2, "south")

      actual_list_north = Enum.map(northern_edge_tiles, fn tile -> Elixir.Map.take(tile, [:row, :col, :character]) end)
                          |> Enum.sort(fn a,b -> {a.row, a.col} < {b.row, b.col} end)

      expected_list_north = Enum.map(0..20, fn i -> %{row: 20, col: i, character: " "} end)
      assert expected_list_north == actual_list_north

      # Bad input
      refute Dungeons.map_edge_tiles(nil, "north")
      refute Dungeons.map_edge_tiles(map_1, nil)

      # other attributes selected, nilling out other attrs not selected
      expected = Enum.map(0..20, fn _ -> %{character: " ", row: nil, col: nil} end)
      actual = Dungeons.map_edge_tiles(map_2, "south", [:character])
               |> Enum.map(fn t -> Elixir.Map.take(t, [:character, :row, :col]) end)
      assert length(expected) == length(actual)
      assert ^expected = actual
    end
  end

  describe "dungeon_map_tiles" do
    alias DungeonCrawl.Dungeons.MapTile

    @valid_attrs %{row: 15, col: 42}
    @invalid_attrs %{row: nil}

    def tile_template_fixture() do
      DungeonCrawl.TileTemplates.create_tile_template %{name: "X", description: "an x", character: "X"}
    end

    def map_tile_fixture(attrs \\ %{}, dungeon_id \\ nil) do
      {:ok, map} = if dungeon_id do
                     {:ok, Dungeons.get_map(dungeon_id)}
                   else
                     map_set = insert_map_set()
                     Dungeons.create_map(%{map_set_id: map_set.id, name: "test", width: 20, height: 20})
                   end
      {:ok, tile_template} = tile_template_fixture()
      {:ok, map_tile} =
        Elixir.Map.merge(%MapTile{}, @valid_attrs)
        |> Elixir.Map.merge(%{dungeon_id: map.id})
        |> Elixir.Map.merge(%{tile_template_id: tile_template.id})
        |> Elixir.Map.merge(attrs)
        |> Repo.insert()

      map_tile
    end

    test "list_dungeon_map_tiles/0 returns all dungeon_map_tiles" do
      map_tile = map_tile_fixture()
      assert Dungeons.list_dungeon_map_tiles() == [map_tile]
    end

    test "get_map_tile!/1 returns the map_tile with given id" do
      map_tile = map_tile_fixture()
      assert Dungeons.get_map_tile!(map_tile.id) == map_tile
    end

    test "get_map_tile!/1 returns the map tile with given map values (using the highest z_index)" do
      map_tile = map_tile_fixture(%{z_index: 1})
      lower_map_tile = map_tile_fixture(%{z_index: 0}, map_tile.dungeon_id)
      assert Dungeons.get_map_tile!(Map.take(lower_map_tile, [:dungeon_id, :row, :col])) == map_tile
    end

    test "get_map_tile!/1 returns the map tile with given map values" do
      map_tile = map_tile_fixture(%{z_index: 1})
      lower_map_tile = map_tile_fixture(%{z_index: 0}, map_tile.dungeon_id)
      assert Dungeons.get_map_tile!(Map.take(lower_map_tile, [:dungeon_id, :row, :col, :z_index])) == lower_map_tile
      assert Dungeons.get_map_tile!(Map.take(map_tile, [:dungeon_id, :row, :col, :z_index])) == map_tile
    end

    test "copy_map_tile_fields/1" do
      map_tile = map_tile_fixture()
      assert %{animate_background_colors: nil,
               animate_characters: nil,
               animate_colors: nil,
               animate_period: nil,
               animate_random: nil,
               background_color: nil,
               character: nil,
               col: 42,
               color: nil,
               name: nil,
               row: 15,
               script: "",
               state: nil,
               tile_template_id: map_tile.tile_template_id,
               z_index: 0} == Dungeons.copy_map_tile_fields(map_tile)
    end

    test "create_map_tile/1 with valid data creates a map_tile" do
      dungeon = insert_stubbed_dungeon()
      {:ok, tile_template} = tile_template_fixture()
      assert {:ok, %MapTile{} = _map_tile} = Dungeons.create_map_tile(Map.merge @valid_attrs, %{dungeon_id: dungeon.id, tile_template_id: tile_template.id})
    end

    test "create_map_tile/1 with invalid data returns error changeset" do
      assert {:error, %Ecto.Changeset{}} = Dungeons.create_map_tile(@invalid_attrs)
    end

   test "create_map_tile!/1 with valid data creates a map_tile" do
      dungeon = insert_stubbed_dungeon()
      {:ok, tile_template} = tile_template_fixture()
      assert %MapTile{} = Dungeons.create_map_tile!(Map.merge @valid_attrs, %{dungeon_id: dungeon.id, tile_template_id: tile_template.id})
    end

    test "update_map_tile/2 with valid data updates the map_tile" do
      map_tile = map_tile_fixture()
      {:ok, tile_template} = tile_template_fixture()
      old_tile_template = map_tile.tile_template_id
      assert {:ok, map_tile} = Dungeons.update_map_tile(map_tile, %{tile_template_id: tile_template.id})
      assert %MapTile{} = map_tile
      refute old_tile_template == map_tile.tile_template_id
    end

    test "update_map_tile/2 with invalid data returns error changeset" do
      map_tile = map_tile_fixture()
      assert {:error, %Ecto.Changeset{}} = Dungeons.update_map_tile(map_tile, @invalid_attrs)
      assert map_tile == Dungeons.get_map_tile!(map_tile.id)
    end

    test "update_map_tile/1 with valid data updates the map_tile" do
      map_tile = map_tile_fixture()
      {:ok, tile_template} = tile_template_fixture()
      old_tile_template = map_tile.tile_template_id
      assert {:ok, map_tile} = Dungeons.update_map_tile(%{dungeon_id: map_tile.dungeon_id, row: map_tile.row, col: map_tile.col},
                                                       %{tile_template_id: tile_template.id})
      assert %MapTile{} = map_tile
      refute old_tile_template == map_tile.tile_template_id
    end

    test "update_map_tile!/2 with valid data updates the map_tile" do
      map_tile = map_tile_fixture()
      {:ok, tile_template} = tile_template_fixture()
      old_tile_template = map_tile.tile_template_id
      assert %MapTile{} = map_tile = Dungeons.update_map_tile!(map_tile, %{tile_template_id: tile_template.id})
      refute old_tile_template == map_tile.tile_template_id
    end

    test "update_map_tile!/1 with valid data updates the map_tile" do
      map_tile = map_tile_fixture()
      {:ok, tile_template} = tile_template_fixture()
      old_tile_template = map_tile.tile_template_id
      assert %MapTile{} = map_tile = Dungeons.update_map_tile!(%{dungeon_id: map_tile.dungeon_id, row: map_tile.row, col: map_tile.col},
                                                              %{tile_template_id: tile_template.id})
      refute old_tile_template == map_tile.tile_template_id
    end

    test "change_map_tile/1 returns a map_tile changeset" do
      map_tile = map_tile_fixture()
      assert %Ecto.Changeset{} = Dungeons.change_map_tile(map_tile)
    end

    test "get_map_tile/1 returns a map_tile from the top" do
      bottom_tile = map_tile_fixture(%{z_index: 0})
      map_tile = map_tile_fixture(%{z_index: 1}, bottom_tile.dungeon_id)
      assert Dungeons.get_map_tile(%{dungeon_id: map_tile.dungeon_id, row: map_tile.row, col: map_tile.col}) == map_tile
      refute Dungeons.get_map_tile(%{dungeon_id: map_tile.dungeon_id+1, row: map_tile.row, col: map_tile.col})
    end

    test "get_map_tile/1 returns a map_tile for the coords including the top" do
      bottom_tile = map_tile_fixture(%{z_index: 0})
      map_tile = map_tile_fixture(%{z_index: 1}, bottom_tile.dungeon_id)
      assert Dungeons.get_map_tile(%{dungeon_id: map_tile.dungeon_id, row: map_tile.row, col: map_tile.col, z_index: 0}) == bottom_tile
      refute Dungeons.get_map_tile(%{dungeon_id: map_tile.dungeon_id+1, row: map_tile.row, col: map_tile.col})
    end

    test "get_map_tile/4 returns a map_tile with given z_index" do
      bottom_tile = map_tile_fixture()
      map_tile = map_tile_fixture(%{z_index: 1}, bottom_tile.dungeon_id)
      assert Dungeons.get_map_tile(map_tile.dungeon_id, map_tile.row, map_tile.col, 0) == bottom_tile
      refute Dungeons.get_map_tile(map_tile.dungeon_id, map_tile.row, map_tile.col, 0) == map_tile
      refute Dungeons.get_map_tile(map_tile.dungeon_id, map_tile.row, map_tile.col, 99)
    end

    test "get_map_tile/3 returns a map_tile with highest z_index" do
      bottom_tile = map_tile_fixture()
      map_tile = map_tile_fixture(%{z_index: 1}, bottom_tile.dungeon_id)
      assert Dungeons.get_map_tile(map_tile.dungeon_id, map_tile.row, map_tile.col) == map_tile
      refute Dungeons.get_map_tile(map_tile.dungeon_id + 1, map_tile.row, map_tile.col)
    end

    test "get_map_tiles/1 returns a map_tile from the top" do
      bottom_tile = map_tile_fixture()
      map_tile = map_tile_fixture(%{z_index: 1}, bottom_tile.dungeon_id)
      assert Dungeons.get_map_tiles(%{dungeon_id: map_tile.dungeon_id, row: map_tile.row, col: map_tile.col}) == [map_tile, bottom_tile]
      assert Dungeons.get_map_tiles(%{dungeon_id: map_tile.dungeon_id+1, row: map_tile.row, col: map_tile.col}) == []
    end

    test "get_map_tiles/3 returns a map_tile" do
      bottom_tile = map_tile_fixture()
      map_tile = map_tile_fixture(%{z_index: 1}, bottom_tile.dungeon_id)
      assert Dungeons.get_map_tiles(map_tile.dungeon_id, map_tile.row, map_tile.col) == [map_tile, bottom_tile]
      assert Dungeons.get_map_tiles(map_tile.dungeon_id + 1, map_tile.row, map_tile.col) == []
    end

    test "delete_map_tile/4 returns the deleted map_tile" do
      tile = map_tile_fixture()
      assert {:ok, deleted_tile} = Dungeons.delete_map_tile(tile.dungeon_id, tile.row, tile.col, tile.z_index)
      assert tile.id == deleted_tile.id
      refute Dungeons.get_map_tile(tile.dungeon_id, tile.row, tile.col, tile.z_index)
    end

    test "delete_map_tile/1 returns the deleted map_tile" do
      tile = map_tile_fixture()
      assert {:ok, deleted_tile} = Dungeons.delete_map_tile(tile)
      assert tile.id == deleted_tile.id
      refute Dungeons.get_map_tile(tile.dungeon_id, tile.row, tile.col, tile.z_index)
    end

    test "delete_map_tile/1 returns nil if given nil" do
      refute Dungeons.delete_map_tile(nil)
    end
  end

  describe "spawn_locations" do
    alias DungeonCrawl.Dungeons.SpawnLocation

    test "add_spawn_locations/2" do
      dungeon = insert_autogenerated_dungeon(%{height: 20, width: 20})
      assert {:ok, %{spawn_locations: {2, nil}}} = Dungeons.add_spawn_locations(dungeon.id, [{0,0}, {1,12}, {25, 3}, {0,0}, {0,50}])
      assert [{dungeon.id, 0, 0}, {dungeon.id, 1, 12}] ==
               _spawn_location_coords(Repo.preload(dungeon, :spawn_locations).spawn_locations)
      assert {:ok, %{spawn_locations: {1, nil}}} = Dungeons.add_spawn_locations(dungeon.id, [{1,12}, {8,8}])
      assert [{dungeon.id, 0, 0}, {dungeon.id, 1, 12}, {dungeon.id, 8,8}] ==
               _spawn_location_coords(Repo.preload(dungeon, :spawn_locations).spawn_locations)
    end

    test "clear_spawn_locations/1" do
      dungeon = insert_autogenerated_dungeon(%{height: 20, width: 20})
      Repo.insert_all(SpawnLocation, [%{dungeon_id: dungeon.id, row: 1, col: 0}, %{dungeon_id: dungeon.id, row: 1, col: 2}])
      assert Repo.preload(dungeon, :spawn_locations).spawn_locations != []
      Dungeons.clear_spawn_locations(dungeon.id)
      assert Repo.preload(dungeon, :spawn_locations).spawn_locations == []
    end

    test "set_spawn_locations/2" do
      dungeon = insert_autogenerated_dungeon()
      Repo.insert_all(SpawnLocation, [%{dungeon_id: dungeon.id, row: 1, col: 0}])
      assert [{dungeon.id, 1, 0}] ==
               _spawn_location_coords(Repo.preload(dungeon, :spawn_locations).spawn_locations)
      assert {:ok, %{spawn_locations: {1, nil}}} = Dungeons.set_spawn_locations(dungeon.id, [{8,8}])
      assert [{dungeon.id, 8, 8}] ==
               _spawn_location_coords(Repo.preload(dungeon, :spawn_locations).spawn_locations)
    end

    defp _spawn_location_coords(spawn_locations) do
      spawn_locations
      |> Enum.map(fn(sl) -> {sl.dungeon_id, sl.row, sl.col} end)
      |> Enum.sort
    end
  end
end
