defmodule DungeonCrawl.Shipping.DockWorkerTest do
  use DungeonCrawl.DataCase

  alias DungeonCrawl.Shipping.DockWorker

  alias DungeonCrawl.Dungeons
  alias DungeonCrawl.Shipping
  alias DungeonCrawl.Shipping.{DungeonExports, Json}
  alias DungeonCrawl.Equipment
  alias DungeonCrawl.Equipment.Seeder, as: EquipmentSeeder
  alias DungeonCrawl.Sound.Seeder, as: SoundSeeder
  alias DungeonCrawl.TileTemplates

  setup do
    EquipmentSeeder.gun
    SoundSeeder.click
    SoundSeeder.shoot

#    dock_worker = start_supervised!(DockWorker)
    {:ok, dock_worker} = GenServer.start_link(DockWorker, %{})

    user = insert_user()

    on_exit(fn -> Process.exit(dock_worker, :kill) end)

    %{dock_worker: dock_worker, user: user}
  end

  test "export/1", %{user: user} do
    dungeon = insert_dungeon()
    dungeon_export = Shipping.create_export!(%{dungeon_id: dungeon.id, user_id: user.id})
    Application.put_env(:dungeon_crawl, :test_timestamp, Calendar.strftime(DateTime.now!("Etc/UTC"), "%Y-%m-%d %H:%M:%S UTC"))

    assert %Task{ref: ref} = DockWorker.export(dungeon_export)
    assert_receive {^ref, :ok}

    export_record = Shipping.get_export!(dungeon_export.id)

    encoded_data = DungeonExports.run(dungeon.id) |> Json.encode!()

    assert %{dungeon_id: dungeon.id,
             status: :completed,
             data: encoded_data,
             user_id: user.id,
             file_name: "Autogenerated_v_1.json"}
           == Map.take(export_record, [:dungeon_id, :status, :data, :user_id, :file_name])

    # Jason decode to get a plain non struct back
    assert Map.keys(Jason.decode!(encoded_data)) ==
             [
               "_meta",
               "dungeon",
               "items",
               "levels",
               "sounds",
               "spawn_locations",
               "tile_templates",
               "tiles"
             ]
  end

  @tag capture_log: true
  test "export/1 but with slug not matching a record", %{user: user} do
    bad_tile = %{
      name: "",
      character: "x",
      state: %{"blocking" => true},
      script: "#end\n:touch\n#equip asdfasdf, ?sender",
      row: 1,
      col: 3,
      z_index: 0
    }
    dungeon  = insert_stubbed_dungeon(%{}, %{}, [[bad_tile]])
    dungeon_export = Shipping.create_export!(%{dungeon_id: dungeon.id, user_id: user.id})

    log = ExUnit.CaptureLog.capture_log(fn ->
      assert %Task{ref: ref} = DockWorker.export(dungeon_export)
      assert_receive {^ref, :ok}
    end)

    assert log =~ "poolboy transaction caught error: :exit, {{%Ecto.NoResultsError"
    dungeon_export = Shipping.get_export!(dungeon_export.id)
    assert dungeon_export.status == :failed
    assert dungeon_export.details ==
             "could not find a Item with slug 'asdfasdf' that was referenced in a script or starting equipment"
  end

  test "import/1", %{user: user} do
    dungeon = insert_dungeon(%{user_id: user.id})
    dungeon_import = Shipping.create_import!(%{
      data: DungeonExports.run(dungeon.id) |> Json.encode!(),
      user_id: user.id,
      file_name: "import.json",
      line_identifier: dungeon.line_identifier,
      status: "running",
      details: "leftover details from something",
      log: "first log data"
    })

    assert %Task{ref: ref} = DockWorker.import(dungeon_import)
    assert_receive {^ref, :ok}

    # the original + the imported
    assert 2 == Enum.count(Dungeons.list_dungeons())

    imported_dungeon = Dungeons.list_dungeons() |> Enum.at(1)

    dungeon_import = Shipping.get_import!(dungeon_import.id)
    assert %{dungeon_id: imported_dungeon.id,
             status: :completed,
             user_id: user.id,
             file_name: "import.json",
             line_identifier: dungeon.line_identifier,
             details: nil}
           == Map.take(dungeon_import,
                       [:dungeon_id, :status, :user_id, :file_name, :line_identifier, :details])
    assert user.id == imported_dungeon.user_id
    assert imported_dungeon.version == 2
    assert imported_dungeon.previous_version_id == dungeon.id
    assert dungeon_import.log =~ ~r/Start:/
    assert dungeon_import.log =~ ~r/first log data\z/
  end

  test "import/1 when an asset needs resolution", %{user: user} do
    tile_template = insert_tile_template(%{user_id: user.id})
    item = insert_item(%{script: "#put direction: @facing, slug: #{ tile_template.slug }"})
    dungeon = insert_dungeon(%{user_id: user.id, state: "starting_equipment: #{ item.slug }" })
    data = DungeonExports.run(dungeon.id) |> Json.encode!()
    TileTemplates.update_tile_template(tile_template, %{color: "blue"})
    {:ok, _} = Equipment.delete_item(item)

    dungeon_import = Shipping.create_import!(%{
      data: data,
      user_id: user.id,
      file_name: "import.json",
      line_identifier: dungeon.line_identifier,
      status: "running"
    })

    assert %Task{ref: ref} = DockWorker.import(dungeon_import)
    assert_receive {^ref, :ok}

    # the original, no new dungeon created
    assert 1 == Enum.count(Dungeons.list_dungeons())

    assert %{status: :waiting,
             user_id: user.id,
             file_name: "import.json",
             line_identifier: dungeon.line_identifier}
           == Map.take(Shipping.get_import!(dungeon_import.id),
             [:status, :user_id, :file_name, :line_identifier])
    assert %{log: log} = Shipping.get_import!(dungeon_import.id)
    assert String.contains?(log, "tile_templates - asset exists by slug, creating asset import record")
    assert String.contains?(log, "whip - items - no match found, flagging asset as buildable")
  end

  @tag capture_log: true
  test "import/1 but with corrupted json in the record", %{user: user} do
    dungeon_import = Shipping.create_import!(%{
      data: "{\"dungeon\":{\"autogenerated\":false,\"default_map_height\":25",
      user_id: user.id,
      file_name: "imppport.json"
    })

    log = ExUnit.CaptureLog.capture_log(fn ->
      assert %Task{ref: ref} = DockWorker.import(dungeon_import)
      assert_receive {^ref, :ok}
    end)

    assert 0 == Enum.count(Dungeons.list_dungeons())
    dungeon_import = Shipping.get_import!(dungeon_import.id)
    assert dungeon_import.status == :failed
    assert dungeon_import.details == "error parsing JSON"

    assert log =~ "poolboy transaction caught error: :exit, {{%Jason.DecodeError"
  end

  @tag capture_log: true
  test "import/1 but the genserver timesout", %{user: user} do
    dungeon_import = Shipping.create_import!(%{
      data: DungeonCrawlWeb.ExportFixture.minimal_export() |> Jason.encode!(),
      user_id: user.id,
      file_name: "imppport.json"
    })

    log = ExUnit.CaptureLog.capture_log(fn ->
            assert %Task{ref: ref} = DockWorker.import(dungeon_import, 1)
            assert_receive {^ref, :ok}
          end)

    # Its possible that assets will still be created on a timeout.

    assert log =~ "poolboy transaction caught error: :exit, {:timeout, {GenServer"
  end
end
