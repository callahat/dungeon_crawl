defmodule DungeonCrawlWeb.CrawlerTest do
  use DungeonCrawlWeb.ChannelCase

  alias DungeonCrawlWeb.LevelChannel
  alias DungeonCrawlWeb.Crawler

  alias DungeonCrawl.Dungeons
  alias DungeonCrawl.Dungeons.{Dungeon, Tile}
  alias DungeonCrawl.DungeonInstances
  alias DungeonCrawl.DungeonProcesses.{Levels, LevelProcess, Registrar, DungeonRegistry}
  alias DungeonCrawl.Games.Save
  alias DungeonCrawl.Equipment
  alias DungeonCrawl.Player
  alias DungeonCrawl.Repo
  alias DungeonCrawl.StateValue.Parser

  import DungeonCrawl.GamesFixtures

  test "join_and_broadcast/4 joining a dungeon" do
    Equipment.Seeder.gun()
    insert_item(%{name: "Fists"})

    dungeon = insert_autogenerated_dungeon(%{state: "starting_equipment: fists gun"})
    assert {dungeon_instance_id, location} = Crawler.join_and_broadcast(dungeon, "itsmehash", %{color: "red"}, true)
    assert %Player.Location{} = location
    tile = Repo.preload(location, [tile: :level]).tile
    assert dungeon_instance_id == tile.level.dungeon_instance_id

    # It registers the player location
    {:ok, instance} = Registrar.instance_process(tile.level)
    location_tile_id = tile.id
    assert %Levels{player_locations: %{^location_tile_id => ^location},
                   map_by_ids: %{^location_tile_id => player_tile}}
           = LevelProcess.get_state(instance)
    assert player_tile.parsed_state[:equipment] == ["fists", "gun"]

    # cleanup
    DungeonRegistry.remove(DungeonInstanceRegistry, tile.level.dungeon_instance_id)
  end

  test "join_and_broadcast/4 joining an instance" do
    Equipment.Seeder.gun()

    di = insert_autogenerated_dungeon_instance()
    di_id = di.id
    instance = Repo.preload(di, :levels).levels |> Enum.at(0)
    location = insert_player_location(%{level_instance_id: instance.id, row: 1, user_id_hash: "itsmehash", state: "cash: 2, score: 10"})

    {:ok, _, _socket} =
      socket(DungeonCrawlWeb.UserSocket, "user_id_hash", %{user_id_hash: location.user_id_hash})
      |> subscribe_and_join(LevelChannel, "level:#{di.id}:#{instance.number}:#{instance.player_location_id}")

    assert {^di_id, location} = Crawler.join_and_broadcast(di, "itsmehash", %{color: "red", background_color: "green"}, nil)
    assert %Player.Location{} = location
    tile = Repo.preload(location, :tile).tile

    expected_row = tile.row
    expected_col = tile.col
    assert_broadcast "tile_changes", %{tiles: [%{row: ^expected_row, col: ^expected_col, rendering: "<div>@</div>"}]}

    # It registers the player location
    {:ok, instance} = Registrar.instance_process(instance)
    location_tile_id = tile.id
    assert %Levels{player_locations: %{^location_tile_id => ^location}} = LevelProcess.get_state(instance)

    # cleanup
    DungeonRegistry.remove(DungeonInstanceRegistry, di.id)
  end

  test "load_and_broadcast/4 loading a save" do
    Equipment.Seeder.gun()

    user = insert_user()
    save = Repo.preload(save_fixture(%{user_id_hash: user.user_id_hash, row: 0, col: 0}), :dungeon_instance)
    level_instance = DungeonInstances.get_level(save.level_instance_id)
    di_id = save.dungeon_instance.id

    other_user = insert_user()
    insert_player_location(%{level_instance_id: level_instance.id, row: 1, user_id_hash: other_user.user_id_hash, state: "cash: 2, score: 10"})

    # the user won't be here yet, but other players might so go ahead and broadcast
    # to any that might witness
    {:ok, _, _socket} =
      socket(DungeonCrawlWeb.UserSocket, "user_id_hash", %{user_id_hash: other_user.user_id_hash})
      |> subscribe_and_join(LevelChannel, "level:#{di_id}:#{level_instance.number}:")

    assert tile = Crawler.load_and_broadcast(save.id)
    assert location = Player.get_location(user.user_id_hash)

    expected_row = tile.row
    expected_col = tile.col
    assert save.row == tile.row
    assert save.col == tile.col
    expected_rendering = "<div style='color: #{user.color};background-color: #{user.background_color}'>@</div>"

    assert_broadcast "tile_changes",
                     %{tiles: [%{
                       row: ^expected_row,
                       col: ^expected_col,
                       rendering: ^expected_rendering}]}

    level_instance = DungeonInstances.get_level(save.level_instance_id)

    # It registers the player location
    {:ok, instance} = Registrar.instance_process(level_instance)
    location_tile_id = tile.id
    assert %Levels{player_locations: %{^location_tile_id => ^location}} = LevelProcess.get_state(instance)

    # cleanup
    DungeonRegistry.remove(DungeonInstanceRegistry, di_id)
  end

  test "load_and_broadcast/4 but its a bad save" do
    # there are other possible errors, but testing one is sufficient for this level
    assert {:error, "Save not found"} = Crawler.load_and_broadcast(-1)
  end

  test "leave_and_broadcast" do
    di = insert_autogenerated_dungeon_instance()
    Repo.update Dungeon.changeset(Repo.preload(di, :dungeon).dungeon, %{autogenerated: false})
    level_instance = Repo.preload(di, :levels).levels |> Enum.at(0)
    location = insert_player_location(%{level_instance_id: level_instance.id, row: 1, user_id_hash: "itsmehash", state: "cash: 2, score: 10"})
    location2 = insert_player_location(%{level_instance_id: level_instance.id, row: 2, user_id_hash: "someoneelsetokeeptheinstance"})
    location2_id = location2.tile_instance_id

    {:ok, _, _socket} =
      socket(DungeonCrawlWeb.UserSocket, "user_id_hash", %{user_id_hash: "itsmehash"})
      |> subscribe_and_join(LevelChannel, "level:#{di.id}:#{level_instance.number}:#{level_instance.player_location_id}")

    # PLAYER LEAVES, AND ONE PLAYER IS LEFT ----
    assert %Player.Location{} = location = Repo.preload(Crawler.leave_and_broadcast(location), :tile)

    expected_row = location.tile.row
    expected_col = location.tile.col
    rendering = "<div style='color: gray;background-color: linen'>Ð”</div>"
    assert_broadcast "tile_changes", %{tiles: [%{row: ^expected_row, col: ^expected_col, rendering: ^rendering}]}

    # It unregisters the player location
    {:ok, instance} = Registrar.instance_process(level_instance)
    state = LevelProcess.get_state(instance)
    assert %{^location2_id => %{user_id_hash: "someoneelsetokeeptheinstance"}} = state.player_locations

    # It dropped the players stuff
    junk_pile = Levels.get_tile(state, location.tile)
    assert junk_pile.script =~ ~r/#GIVE cash, 2, \?sender/i

    # It did not destroy the dungeon as its not marked as autogenerated
    assert Dungeons.get_dungeon(di.dungeon_id)

    # No score was created
    assert DungeonCrawl.Repo.all(DungeonCrawl.Scores.Score) == []

    # cleanup
    DungeonRegistry.remove(DungeonInstanceRegistry, di.id)
  end

  test "leave_and_broadcast deletes dungeon when its autogenerated" do
    di = insert_autogenerated_dungeon_instance()
    level_instance = Repo.preload(di, :levels).levels |> Enum.at(0)
    location = insert_player_location(%{level_instance_id: level_instance.id, row: 1, user_id_hash: "itsmehash", state: "cash: 2, score: 10"})
    _location2 = insert_player_location(%{level_instance_id: level_instance.id, row: 2, user_id_hash: "someoneelsetokeeptheinstance"})

    {:ok, _, _socket} =
      socket(DungeonCrawlWeb.UserSocket, "user_id_hash", %{user_id_hash: "itsmehash"})
      |> subscribe_and_join(LevelChannel, "level:#{di.id}:#{level_instance.number}:#{level_instance.player_location_id}")

    # PLAYER LEAVES
    assert %Player.Location{} = Crawler.leave_and_broadcast(location)

    # It did not destroy the dungeon
    assert Dungeons.get_dungeon(di.dungeon_id)

    # Score was created
    assert [score] = DungeonCrawl.Repo.all(DungeonCrawl.Scores.Score)
    assert score.result == "Gave Up, Level: 1"

    # cleanup
    DungeonRegistry.remove(DungeonInstanceRegistry, di.id)
  end

  test "save_and_leave_and_broadcast/1" do
    level_instance = insert_stubbed_level_instance(%{},
      [%Tile{character: ".", row: 1, col: 1, z_index: 0}])

    di = DungeonCrawl.Repo.preload(level_instance, :dungeon).dungeon

    location = insert_player_location(%{level_instance_id: level_instance.id, row: 1, user_id_hash: "itsmehash", state: "cash: 2, score: 10"})

    location = location
               |> Player.change_location()
               |> Ecto.Changeset.put_change(:inserted_at, NaiveDateTime.add(location.inserted_at, -120))
               |> Repo.update!()
               |> Repo.preload([:tile])

    {:ok, _, _socket} =
      socket(DungeonCrawlWeb.UserSocket, "user_id_hash", %{user_id_hash: "itsmehash"})
      |> subscribe_and_join(LevelChannel, "level:#{di.id}:#{level_instance.number}:#{level_instance.player_location_id}")

    expected_row = location.tile.row
    expected_col = location.tile.col
    expected_rendering = "<div>.</div>"

    # PLAYER LEAVES, AND ONE PLAYER IS LEFT ----
    assert %Save{} = save = Crawler.save_and_leave_and_broadcast(location)

    assert_broadcast "tile_changes", %{tiles: [%{row: ^expected_row, col: ^expected_col, rendering: ^expected_rendering}]}

    # It unregisters the player location
    {:ok, instance} = Registrar.instance_process(level_instance)
    state = LevelProcess.get_state(instance)
    assert %{} == state.player_locations

    # It did not destroy the dungeon
    assert Dungeons.get_dungeon(di.dungeon_id)

    # No score is created
    assert DungeonCrawl.Repo.all(DungeonCrawl.Scores.Score) == []

    # It creates the save
    assert %Save{user_id_hash: "itsmehash", state: state} = save
    %{duration: duration} = Parser.parse!(state)
    assert_in_delta duration, 120, 1

    # cleanup
    DungeonRegistry.remove(DungeonInstanceRegistry, di.id)
  end
end
